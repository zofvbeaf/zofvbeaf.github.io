<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[剑指offer]]></title>
    <url>%2Falgorithms%2Fjzoffer.html</url>
    <content type="text"><![CDATA[剑指offer 按牛客网的顺序。 二维数组中的查找 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 123456789101112131415161718class Solution &#123;public: bool Find(int target, vector&lt;vector&lt;int&gt; &gt; array) &#123; if(array.empty() || array[0].empty() || array[0][0] &gt; target) return false; int n = array.size(), m = array[0].size(); int i = 0, j = m-1; while(i &lt; n &amp;&amp; j &gt;= 0) &#123; if(array[i][j] == target) return true; else if(array[i][j] &lt; target) ++i; else --j; &#125; return false; &#125;&#125;; 替换空格 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 1234567891011121314151617181920212223242526class Solution &#123;public: void replaceSpace(char *str,int length) &#123; if(!str) return; int old_len = 0; int space_num = 0; while(str[old_len] != '\0') &#123; if(str[old_len++] == ' ') ++space_num; &#125; int new_len = space_num*2 + old_len; if(new_len &gt; length) return; for(int i = old_len, j = new_len; i &gt;= 0; --i, --j) &#123; if(str[i] == ' ') &#123; str[j] = '0'; str[j-1] = '2'; str[j-2] = '%'; j -= 2; &#125; else str[j] = str[i]; &#125; &#125;&#125;; 从尾到头打印链表 输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 123456789101112131415161718192021222324/*** struct ListNode &#123;* int val;* struct ListNode *next;* ListNode(int x) :* val(x), next(NULL) &#123;* &#125;* &#125;;*/class Solution &#123;public: void addValue(vector&lt;int&gt;&amp; ans, ListNode* node) &#123; if(!node) return; addValue(ans, node-&gt;next); ans.push_back(node-&gt;val); &#125; vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; ans; if(!head) return ans; addValue(ans, head); return ans; &#125;&#125;; 重建二叉树 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 12345678910111213141516171819202122232425262728293031323334/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* solve(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; vin, int pstart, int pend, int vstart, int vend) &#123; if(pstart &gt; pend || vstart &gt; vend) return nullptr; TreeNode* root = new TreeNode(pre[pstart]); int vroot_pos = vstart; while(vroot_pos &lt;= vend) &#123; if(vin[vroot_pos] == pre[pstart]) break; else vroot_pos++; &#125; root-&gt;left = solve(pre, vin, pstart+1, pstart+vroot_pos-vstart, vstart, vroot_pos-1); root-&gt;right = solve(pre, vin, pend-(vend-vroot_pos)+1, pend, vroot_pos+1, vend); return root; &#125; TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; vin) &#123; if(pre.empty() || vin.empty() || pre.size() != vin.size()) return nullptr; return solve(pre, vin, 0, pre.size()-1, 0, vin.size()-1); &#125;&#125;; 用两个栈实现队列 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 123456789101112131415161718192021222324class Solution&#123; public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; if(stack2.empty()) &#123; while(!stack1.empty()) &#123; int temp = stack1.top(); stack2.push(temp); stack1.pop(); &#125; &#125; int res = stack2.top(); stack2.pop(); return res; &#125; private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; 旋转数组的最小数字 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 12345678910111213141516171819202122232425class Solution &#123; public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int left = 0, right = rotateArray.size() - 1, mid = 0; while(rotateArray[left] &gt;= rotateArray[right]) &#123; if(right - left == 1) return rotateArray[right]; if(rotateArray[left] == rotateArray[mid] &amp;&amp; rotateArray[right] == rotateArray[mid]) &#123; int res = rotateArray[left]; while(left &lt;= right) &#123; res = res &lt; rotateArray[left] ? res : rotateArray[left]; ++left; &#125; return res; &#125; int mid = (left+right) &gt;&gt; 1; if(rotateArray[left] &lt;= rotateArray[mid]) left = mid; else if(rotateArray[mid] &lt;= rotateArray[right]) right = mid; &#125; return rotateArray[mid]; &#125;&#125;; 斐波那契数列 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39 12345678910111213class Solution &#123; public: int Fibonacci(int n) &#123; if(n &lt; 2) return n; int x = 0, y = 1; while(--n) &#123; int temp = x; x = y; y += temp; &#125; return y; &#125;&#125;; 跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 1234567891011121314class Solution &#123;public: int jumpFloor(int number) &#123; int n = number; if(n &lt; 2) return n; int x = 1, y = 1; while(--n) &#123; int temp = x; x = y; y += temp; &#125; return y; &#125;&#125;; 变态跳台阶 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 123456class Solution &#123;public: int jumpFloorII(int number) &#123; return 1 &lt;&lt; (number-1); &#125;&#125;; 矩形覆盖 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 1234567891011121314151617class Solution &#123; public: int rectCover(int number) &#123; if(number &lt;= 0) return 0; if(number &lt;= 3) return number; int x = 1, y = 2; number -= 2; while(number--) &#123; int temp = y; y += x; x = temp; &#125; return y; &#125;&#125;; 二进制中1的个数 输入一个整数，输出该数二进制表示中1的个数。其中负数用补码表示。 1234567891011class Solution &#123;public: int NumberOf1(int n) &#123; int ans = 0; while(n) &#123; ++ans; n = (n-1) &amp; n; &#125; return ans; &#125;&#125;; 数值的整数次方 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 12345678910111213141516171819202122232425class Solution &#123;public: double Power(double base, int exponent) &#123; if(base == 0) &#123; if(exponent == 0) return 1; else return 0; &#125; if(exponent == 0) &#123; return 1; &#125; else if(exponent &lt; 0) &#123; exponent = -exponent; base = 1.0/base; &#125; double ans = 1; while(exponent) &#123; if(exponent &amp; 1) &#123; ans = ans * base; &#125; base *= base; exponent &gt;&gt;= 1; &#125; return ans; &#125;&#125;; 调整数组使奇数位于偶数前面 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 123456789101112131415161718class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; vector&lt;int&gt; temp_evens; for(auto it = array.begin(); it != array.end();) &#123; if((*it)%2 == 0) &#123; temp_evens.push_back((*it)); array.erase(it); &#125; else &#123; ++it; &#125; &#125; for(auto&amp; i : temp_evens) &#123; array.push_back(i); &#125; &#125; &#125;; 若不用保证奇数和奇数，偶数和偶数之间的相对位置不变。 1234567891011class Solution &#123;public: void reOrderArray(vector&lt;int&gt; &amp;array) &#123; int l = 0, r = array.size() - 1; while (l &lt; r) &#123; while (l &lt; r &amp;&amp; array[l] % 2 == 1) ++l; while (l &lt; r &amp;&amp; array[r] % 2 == 0) --r; if (l &lt; r) swap(array[l], array[r]); &#125; &#125;&#125;; 链表中倒数第k个节点 输入一个链表，输出该链表中倒数第k个结点。 1234567891011121314151617181920212223242526272829/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindKthToTail(ListNode* pListHead, int k) &#123; if(!pListHead || k == 0) return nullptr; ListNode* pa = pListHead; ListNode* pb = nullptr; for(int i = 0; i &lt; k-1; ++i) &#123; pa = pa-&gt;next; if(!pa) &#123; return nullptr; &#125; &#125; pb = pListHead; while(pa-&gt;next != nullptr) &#123; pa = pa-&gt;next; pb = pb-&gt;next; &#125; return pb; &#125;&#125;; 反转链表 输入一个链表，反转链表后，输出新链表的表头。 12345678910111213141516171819202122232425262728/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* ReverseList(ListNode* head) &#123; if(!head || head-&gt;next == nullptr) &#123; return head; &#125; ListNode* temp_head = head; ListNode* ans = nullptr; ListNode* temp_prev = nullptr; while(temp_head) &#123; ListNode* temp_next = temp_head-&gt;next; if(!temp_next) ans = temp_head; temp_head-&gt;next = temp_prev; temp_prev = temp_head; temp_head = temp_next; &#125; return ans; &#125;&#125;; 合并两个排序的链表 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 12345678910111213141516171819202122232425262728293031/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* Merge(ListNode* pHead1, ListNode* pHead2) &#123; ListNode *dummy = new ListNode(0); ListNode *cur = dummy; while (pHead1 != NULL &amp;&amp; pHead2 != NULL) &#123; if (pHead1 -&gt; val &lt; pHead2 -&gt; val) &#123; cur -&gt; next = pHead1; pHead1 = pHead1 -&gt; next; &#125; else &#123; cur -&gt; next = pHead2; pHead2 = pHead2 -&gt; next; &#125; cur = cur -&gt; next; &#125; cur -&gt; next = (pHead1 ? pHead1 : pHead2); cur = dummy -&gt; next; delete dummy; return cur; &#125;&#125;; 树的子结构 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 12345678910111213141516171819202122232425262728293031/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2) &#123; if(!pRoot2 || !pRoot1) &#123; return false; &#125; if(pRoot1-&gt;val == pRoot2-&gt;val) &#123; bool left = true, right = true; if(pRoot2-&gt;left) &#123; left = HasSubtree(pRoot1-&gt;left, pRoot2-&gt;left); &#125; if(pRoot2-&gt;right) &#123; right = HasSubtree(pRoot1-&gt;right, pRoot2-&gt;right); &#125; if(left &amp;&amp; right) return true; &#125; return HasSubtree(pRoot1-&gt;left, pRoot2) || HasSubtree(pRoot1-&gt;right, pRoot2); &#125;&#125;; 二叉树的镜像 操作给定的二叉树，将其变换为源二叉树的镜像。 12345678910111213141516171819202122/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void Mirror(TreeNode *pRoot) &#123; if(!pRoot) &#123; return; &#125; TreeNode* temp = pRoot-&gt;left; pRoot-&gt;left = pRoot-&gt;right; pRoot-&gt;right = temp; Mirror(pRoot-&gt;left); Mirror(pRoot-&gt;right); &#125;&#125;; 顺时针打印矩阵 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123;public: void printMatrixCircle(vector&lt;vector&lt;int&gt; &gt;&amp; matrix, int start, vector&lt;int&gt;&amp; ans) &#123; int rows = matrix.size(), columns = matrix[0].size(); int endr = rows-start-1; int endc = columns-start-1; for(int i = start; i &lt;= endc; ++i) &#123; ans.push_back(matrix[start][i]); &#125; for(int i = start+1; i &lt;= endr; ++i) &#123; ans.push_back(matrix[i][endc]); &#125; if(start &lt; endr) &#123; for(int i = endc-1; i &gt;= start; --i) &#123; ans.push_back(matrix[endr][i]); &#125; &#125; if(start &lt; endc) &#123; for(int i = endr-1; i &gt; start; --i) &#123; ans.push_back(matrix[i][start]); &#125; &#125; &#125; vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt;&amp; matrix) &#123; vector&lt;int&gt; ans; if(matrix.empty()) &#123; return ans; &#125; if(matrix.size() == 1) &#123; ans = matrix[0]; return ans; &#125; int rows = matrix.size(), columns = matrix[0].size(); int start = 0; while(start*2 &lt; rows &amp;&amp; start*2 &lt; columns) &#123; printMatrixCircle(matrix, start, ans); ++start; &#125; return ans; &#125;&#125;; 包含min函数的栈 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 1234567891011121314151617181920212223242526class Solution &#123;public: void push(int value) &#123; data.push(value); if(min_data.empty() || min_data.top() &gt; value) &#123; min_data.push(value); &#125; else &#123; min_data.push(min_data.top()); &#125; &#125; void pop() &#123; data.pop(); min_data.pop(); &#125; int top() &#123; return data.top(); &#125; int min() &#123; return min_data.top(); &#125; private: stack&lt;int&gt; data; stack&lt;int&gt; min_data;&#125;; 栈的压入弹出序列 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 12345678910111213141516171819202122class Solution &#123;public: bool IsPopOrder(vector&lt;int&gt; pushV,vector&lt;int&gt; popV) &#123; if(pushV.size() != popV.size()) &#123; return false; &#125; if(pushV.empty()) &#123; return true; &#125; stack&lt;int&gt; temp_stack; int i = 0, j = 0; while(i &lt; pushV.size()) &#123; temp_stack.push(pushV[i]); while(j &lt; popV.size() &amp;&amp; temp_stack.top() == popV[j]) &#123; temp_stack.pop(); ++j; &#125; ++i; &#125; return temp_stack.empty(); &#125;&#125;; 从上往下打印二叉树 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 1234567891011121314151617181920212223242526272829303132/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; PrintFromTopToBottom(TreeNode* root) &#123; vector&lt;int&gt; ans; if(!root) &#123; return ans; &#125; queue&lt;TreeNode*&gt; temp_queue; temp_queue.push(root); while(!temp_queue.empty()) &#123; TreeNode* temp_node = temp_queue.front(); ans.push_back(temp_node-&gt;val); temp_queue.pop(); if(temp_node-&gt;left) &#123; temp_queue.push(temp_node-&gt;left); &#125; if(temp_node-&gt;right) &#123; temp_queue.push(temp_node-&gt;right); &#125; &#125; return ans; &#125;&#125;; 二叉搜索树的后序遍历序列 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 123456789101112131415161718192021222324252627282930class Solution &#123;public: bool VerifySquenceOfBSTCore(vector&lt;int&gt;&amp; sequence, int x, int y) &#123; if(x &gt;= y) return true; int root = sequence[y]; int left = 0; for(; left &lt; y; ++left) &#123; if(sequence[left] &gt; root) &#123; break; &#125; &#125; int right = left; --left; for(; right &lt; y; ++right) &#123; if(sequence[right] &lt; root) &#123; return false; &#125; &#125; return VerifySquenceOfBSTCore(sequence, x, left) &amp;&amp; VerifySquenceOfBSTCore(sequence, right, y-1); &#125; bool VerifySquenceOfBST(vector&lt;int&gt; sequence) &#123; if(sequence.empty()) &#123; return false; &#125; return VerifySquenceOfBSTCore(sequence, 0, sequence.size()-1); &#125;&#125;; 二叉树中和为某一值的路径 输入一颗二叉树的跟节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 12345678910111213141516171819202122232425262728293031323334/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void FindPathCore(vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt; &gt;&amp; ans, int tempsum, TreeNode* root,int expectNumber) &#123; if(!root) return; tempsum += root-&gt;val; path.push_back(root-&gt;val); if(root-&gt;left == nullptr &amp;&amp; root-&gt;right == nullptr &amp;&amp; tempsum == expectNumber) &#123; ans.push_back(path); &#125; FindPathCore(path, ans, tempsum, root-&gt;left, expectNumber); FindPathCore(path, ans, tempsum, root-&gt;right, expectNumber); path.pop_back(); &#125; vector&lt;vector&lt;int&gt; &gt; FindPath(TreeNode* root,int expectNumber) &#123; vector&lt;vector&lt;int&gt; &gt; ans; vector&lt;int&gt; path; if(!root) return ans; FindPathCore(path, ans, 0, root, expectNumber); return ans; &#125;&#125;; 复杂链表的复制 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*struct RandomListNode &#123; int label; struct RandomListNode *next, *random; RandomListNode(int x) : label(x), next(NULL), random(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: RandomListNode* Clone(RandomListNode* pHead) &#123; if(!pHead) &#123; return pHead; &#125; RandomListNode* temp_head = pHead; while(temp_head) &#123; RandomListNode* clone_node = new RandomListNode(temp_head-&gt;label); clone_node-&gt;next = temp_head-&gt;next; temp_head-&gt;next = clone_node; temp_head = clone_node-&gt;next; &#125; temp_head = pHead; while(temp_head) &#123; RandomListNode* clone_node = temp_head-&gt;next; if(temp_head-&gt;random) &#123; clone_node-&gt;random = temp_head-&gt;random-&gt;next; &#125; temp_head = clone_node-&gt;next; &#125; temp_head = pHead; RandomListNode* ans = pHead-&gt;next; while(temp_head) &#123; RandomListNode* clone_node = temp_head-&gt;next; temp_head-&gt;next = clone_node-&gt;next; temp_head = temp_head-&gt;next; if(temp_head) &#123; clone_node-&gt;next = temp_head-&gt;next; &#125; &#125; return ans; &#125;&#125;; 二叉搜索树与双向链表 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 12345678910111213141516171819202122232425262728293031323334353637/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void ConvertCore(TreeNode* pRoot, TreeNode** pLastNode) &#123; if(!pRoot) return; if(pRoot-&gt;left) &#123; ConvertCore(pRoot-&gt;left, pLastNode); &#125; pRoot-&gt;left = *pLastNode; if(*pLastNode) &#123; (*pLastNode)-&gt;right = pRoot; &#125; *pLastNode = pRoot; if(pRoot-&gt;right) &#123; ConvertCore(pRoot-&gt;right, pLastNode); &#125; &#125; TreeNode* Convert(TreeNode* pRootOfTree) &#123; TreeNode* pLastNode = nullptr; ConvertCore(pRootOfTree, &amp;pLastNode); while(pLastNode &amp;&amp; pLastNode-&gt;left) &#123; pLastNode = pLastNode-&gt;left; &#125; return pLastNode; &#125;&#125;; 字符串的排列 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: void PermutationCore(string str, vector&lt;string&gt;&amp; ans, int start) &#123; if(start &gt;= str.size()) &#123; ans.push_back(str); return; &#125; unordered_set&lt;char&gt; temp_chars; sort(str.begin() + start, str.end()); for(int i = start; i &lt; str.size(); ++i) &#123; if(temp_chars.count(str[i])) &#123; continue; &#125; temp_chars.insert(str[i]); char c = str[start]; str[start] = str[i]; str[i] = c; PermutationCore(str, ans, start+1); c = str[start]; str[start] = str[i]; str[i] = c; &#125; &#125; vector&lt;string&gt; Permutation(string str) &#123; vector&lt;string&gt; ans; if(str.empty()) &#123; return ans; &#125; PermutationCore(str, ans, 0); return ans; &#125;&#125;; 数组中出现超过一半的数字 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 12345678910111213141516171819202122232425262728class Solution &#123;public: int MoreThanHalfNum_Solution(vector&lt;int&gt; numbers) &#123; if(numbers.empty()) &#123; return 0; &#125; int x = numbers[0], y = 1; for(int i = 1; i &lt; numbers.size(); ++i) &#123; if(numbers[i] != x) &#123; --y; if(y &lt;= 0) &#123; x = numbers[i]; y = 1; &#125; &#125; else &#123; ++y; &#125; &#125; y = 0; for(int i = 0; i &lt; numbers.size(); ++i) &#123; if(numbers[i] == x) ++y; &#125; return y &gt; numbers.size()/2 ? x : 0; &#125;&#125;; 最小的k个数 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 1234567891011121314151617181920212223242526272829303132333435class Solution &#123;public: int partition(vector&lt;int&gt;&amp; input, int left, int right) &#123; int pivot = input[left]; while(left &lt; right) &#123; while(left &lt; right &amp;&amp; input[right] &gt;= pivot) --right; input[left] = input[right]; while(left &lt; right &amp;&amp; input[left] &lt;= pivot) ++left; input[right] = input[left]; &#125; input[left] = pivot; return left; &#125; vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; if(input.size() &lt; k || k &lt;= 0) &#123; return vector&lt;int&gt;(); &#125; else if(input.size() == k) &#123; return input; &#125; int start = 0, end = input.size()-1; int index = partition(input, start, end); while(index != k-1) &#123; if(index &gt; k-1) &#123; end = index-1; &#125; else &#123; start = index+1; &#125; index = partition(input, start, end); &#125; return vector&lt;int&gt;(input.begin(), input.begin()+k); &#125;&#125;; 若不可以改变原数组 123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;int&gt; GetLeastNumbers_Solution(vector&lt;int&gt; input, int k) &#123; vector&lt;int&gt; ans; if(input.size() &lt; k || k &lt;= 0) &#123; return ans; &#125; else if(input.size() == k) &#123; return input; &#125; priority_queue&lt;int&gt; que; for(auto&amp; i : input) &#123; if(que.size() &lt; k) &#123; que.push(i); &#125; else if(!que.empty() &amp;&amp; i &lt; que.top()) &#123; que.pop(); que.push(i); &#125; &#125; while(!que.empty()) &#123; ans.push_back(que.top()); que.pop(); &#125; return ans; &#125;&#125;; 连续子数组的最大和 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 12345678910111213141516171819class Solution &#123;public: int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if(array.empty()) &#123; return INT_MIN; &#125; int ans = array[0], count = array[0]; for(int i = 1; i &lt; array.size(); ++i) &#123; count += array[i]; if(count &gt; ans) &#123; ans = count; &#125; if(count &lt; 0) &#123; count = 0; &#125; &#125; return ans; &#125;&#125;; 从1到n整数中1出现的次数 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 12345678910111213141516171819202122class Solution &#123;public: int NumberOf1Between1AndN_Solution(int n) &#123; if(n &lt; 0) &#123; n = 0-n; &#125; if(n &lt; 10) &#123; return n &gt;= 1; &#125; int ans = 0, base = 1, m = n; while(m) &#123; int x = m%10; m /= 10; ans += m*base; if(x == 1) ans += (n%base)+1; else if(x &gt; 1) ans += base; base *= 10; &#125; return ans; &#125;&#125;; 把数组排成最小的数 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 1234567891011121314class Solution &#123;public: string PrintMinNumber(vector&lt;int&gt; numbers) &#123; sort(numbers.begin(), numbers.end(), [](const int&amp; lhs, const int&amp; rhs)&#123; string left = std::to_string(lhs); string right = std::to_string(rhs); return (left+right) &lt; (right+left); &#125;); string ans; for(auto&amp; i : numbers) ans += std::to_string(i); return ans; &#125;&#125;; 丑数 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 1234567891011121314151617class Solution &#123;public: int GetUglyNumber_Solution(int index) &#123; if(index &lt;= 0) return 0; vector&lt;int&gt; temp &#123;0, 1&#125;; // c++11 int p2 = 1, p3 = 1, p5 = 1; while(temp.size() &lt;= index) &#123; while(2*temp[p2] &lt;= temp.back()) ++p2; while(3*temp[p3] &lt;= temp.back()) ++p3; while(5*temp[p5] &lt;= temp.back()) ++p5; int x = std::min(std::min(2*temp[p2], 3*temp[p3]), 5*temp[p5]); temp.push_back(x); &#125; return temp[index]; &#125; &#125;; 第一次只出现一次的字符的位置 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）. 12345678910111213141516171819class Solution &#123;public: int FirstNotRepeatingChar(string str) &#123; unordered_map&lt;char, int&gt; flag; for(int i = 0; i &lt; str.size(); ++i) &#123; if(!flag.count(str[i])) &#123; flag[str[i]] = i; &#125; else if(flag[str[i]] &gt;= 0) &#123; flag[str[i]] = -1; &#125; &#125; for(int i = 0; i &lt; str.size(); ++i) &#123; if(flag[str[i]] &gt;= 0) return flag[str[i]]; &#125; return -1; &#125;&#125;; 数组中的逆序对 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int InversePairs(vector&lt;int&gt; data) &#123; int ans = 0; vector&lt;int&gt; dup(data); return merge(dup, data, 0, data.size()-1); &#125; int merge(vector&lt;int&gt;&amp; dup, vector&lt;int&gt;&amp; data, int left, int right) &#123; if(left &gt;= right) &#123; dup[left] = data[left]; return 0; &#125; int mid = (left+right)/2; int left_num = merge(dup, data, left, mid); int right_num = merge(dup, data, mid+1, right); int i = mid, j = right, k = right, cnt = (left_num+right_num)%1000000007; while(i &gt;= left &amp;&amp; j &gt; mid) &#123; // important : from right to left if(data[i] &lt;= data[j]) &#123; dup[k--] = data[j--]; &#125; else &#123; dup[k--] = data[i--]; // important: 表示右边的子数组比data[i]小的数的个数 // 如果从左往右统计则可以改为 (cnt + mid - i + 1) 表示当前左边大于data[j]的元素个数 cnt = (cnt + j - mid)%1000000007; &#125; &#125; while(i &gt;= left) &#123; dup[k--] = data[i--]; &#125; while(j &gt; mid) &#123; dup[k--] = data[j--]; &#125; for(i = left; i &lt;= right; ++i) data[i] = dup[i]; return cnt; &#125;&#125;; 两个链表的第一个公共节点 输入两个链表，找出它们的第一个公共结点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindFirstCommonNode(ListNode* pHead1, ListNode* pHead2) &#123; if(!pHead1 || !pHead2) &#123; return nullptr; &#125; int x = 0, y = 0; ListNode *p1 = pHead1, *p2 = pHead2; while(p1) &#123; p1 = p1-&gt;next; ++x; &#125; while(p2) &#123; p2 = p2-&gt;next; ++y; &#125; p1 = pHead1; while(x &gt; y) &#123; p1 = p1-&gt;next; --x; &#125; p2 = pHead2; while(y &gt; x) &#123; p2 = p2-&gt;next; --y; &#125; while(p1 &amp;&amp; p2) &#123; if(p1 == p2) &#123; return p1; &#125; p1 = p1-&gt;next; p2 = p2-&gt;next; &#125; return nullptr; &#125;&#125;; 更简洁的做法，交替走 12345678910111213class Solution &#123;public: ListNode *findFirstCommonNode(ListNode *headA, ListNode *headB) &#123; auto p = headA, q = headB; while(p != q) &#123; if(p) p = p-&gt;next; else p = headB; if (q) q = q-&gt;next; else q = headA; &#125; return p; &#125;&#125;; 数字在排序数组中出现的次数 统计一个数字在排序数组中出现的次数。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int GetNumberOfK(vector&lt;int&gt; data ,int k) &#123; if(data.empty()) &#123; return 0; &#125; // lower_bound int left = 0, right = data.size(); while(left &lt; right) &#123; int mid = (left + right)/2; if(data[mid] &lt; k) &#123; left = mid+1; &#125; else &#123; right = mid; &#125; &#125; if(left &gt;= data.size() || data[left] != k) &#123; return 0; &#125; int last = left; // upper_bound left = 0, right = data.size(); while(left &lt; right) &#123; int mid = (left + right)/2; if(data[mid] &lt;= k) &#123; left = mid+1; &#125; else &#123; right = mid; &#125; &#125; return right-last; &#125;&#125;; 二叉树的深度 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 123456789101112131415161718/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: int TreeDepth(TreeNode* pRoot) &#123; if(!pRoot) return 0; return 1 + std::max(TreeDepth(pRoot-&gt;left), TreeDepth(pRoot-&gt;right)); &#125;&#125;; 平衡二叉树 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 1234567891011121314151617class Solution &#123;public: int TreeDeepth(TreeNode* pRoot) &#123; if(!pRoot) return 0; int left = TreeDeepth(pRoot-&gt;left); int right = TreeDeepth(pRoot-&gt;right); if(left &lt; 0 || right &lt; 0 || abs(left-right) &gt; 1) return -1; return std::max(left, right) + 1; &#125; bool IsBalanced_Solution(TreeNode* pRoot) &#123; if(!pRoot) return true; return TreeDeepth(pRoot) &gt;= 0; &#125;&#125;; 数组中只出现一次的数字 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 1234567891011121314151617181920212223class Solution &#123;public: void FindNumsAppearOnce(vector&lt;int&gt; data,int* num1,int *num2) &#123; int x = 0; for(auto&amp; i : data) &#123; x ^= i; &#125; int px = 0; while(!(x&gt;&gt;px &amp; 1)) &#123; ++px; &#125; int y = 0; x = 0; for(auto&amp; i : data) &#123; if(i&gt;&gt;px &amp; 1) x ^= i; else y ^= i; &#125; *num1 = x; *num2 = y; &#125;&#125;; 数组中唯一只出现一次的数字 在一个数组中除了一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。你可以假设满足条件的数字一定存在。 123456789101112131415161718192021class Solution &#123;public: int findNumberAppearingOnce(vector&lt;int&gt;&amp; nums) &#123; int length = nums.size(); if (length == 0) return -1; int bitsum[32] = &#123;0&#125;; for (int i = 0; i &lt; length; i++)&#123; int bitmask = 1; for (int j = 31; j &gt;= 0; j-- )&#123; bitsum[j] += (nums[i] &amp; bitmask)?1 : 0; bitmask = bitmask &lt;&lt; 1; &#125; &#125; int result = 0; for (int i = 0; i &lt; 32; i++) &#123; result = result &lt;&lt; 1; result += bitsum[i]%3; &#125; return result; &#125;&#125;; 和为S的两个数字 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; FindNumbersWithSum(vector&lt;int&gt; array,int sum) &#123; vector&lt;int&gt; ans; if(array.size() &lt; 2) &#123; return ans; &#125; int left = 0, right = array.size()-1; long long x = sum, y = sum; while(left &lt; right) &#123; if(array[left] + array[right] == sum) &#123; if(array[left]*array[right] &lt; x*y) &#123; x = array[left]; y = array[right]; &#125; --right; &#125; else if(array[left] + array[right] &lt; sum) &#123; ++left; &#125; else &#123; --right; &#125; &#125; if(x + y == sum) &#123; ans.push_back(x); ans.push_back(y); &#125; return ans; &#125;&#125;; 和为S的连续正数序列 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void AddAnswer(vector&lt;vector&lt;int&gt; &gt;&amp; ans, int left, int right) &#123; vector&lt;int&gt; temp; for(int i = left; i &lt;= right; ++i) &#123; temp.push_back(i); &#125; ans.push_back(temp); &#125; vector&lt;vector&lt;int&gt; &gt; FindContinuousSequence(int sum) &#123; vector&lt;vector&lt;int&gt; &gt; ans; if(sum &lt;= 0) &#123; return ans; &#125; int left = 1, right = 2, temp_sum = 1 + 2; while(left &lt; right) &#123; if(temp_sum == sum) &#123; AddAnswer(ans, left, right); temp_sum -= left; ++left; &#125; else if(temp_sum &gt; sum) &#123; temp_sum -= left; ++left; &#125; else &#123; ++right; temp_sum += right; &#125; &#125; return ans; &#125;&#125;; 左旋转字符串 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 1234567891011121314151617181920212223class Solution &#123;public: void reverse(string&amp; str, int left, int right) &#123; while(left &lt; right) &#123; char temp_c = str[left]; str[left] = str[right]; str[right] = temp_c; ++left, --right; &#125; &#125; string LeftRotateString(string str, int n) &#123; string ans; if(str.empty()) &#123; return ans; &#125; n %= str.size(); reverse(str, 0, str.size()-1); reverse(str, str.size()-n, str.size()-1); reverse(str, 0, str.size()-n-1); return str; &#125;&#125;; 反转单词序列 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 123456789101112131415161718192021222324252627282930313233class Solution &#123;public: void reverse(string&amp; str, int left, int right) &#123; while(left &lt; right) &#123; char temp_c = str[left]; str[left] = str[right]; str[right] = temp_c; ++left, --right; &#125; &#125; string ReverseSentence(string str) &#123; if(str.empty()) &#123; return str; &#125; reverse(str, 0, str.size()-1); int left = 0, right = 0; while(left &lt; str.size()) &#123; if(str[left] == ' ') &#123; ++left; right = left; &#125; else if(right == str.size() || str[right] == ' ') &#123; reverse(str, left, right-1); left = ++right; &#125; else &#123; ++right; &#125; &#125; return str; &#125;&#125;; 扑克牌顺子 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 12345678910111213141516171819202122class Solution &#123;public: bool IsContinuous( vector&lt;int&gt; numbers ) &#123; if(numbers.size() &lt; 2) &#123; return !numbers.empty(); &#125; sort(numbers.begin(), numbers.end()); int x = 0, y = 0; for(int i = 0; i &lt; numbers.size(); ++i) &#123; if(!numbers[i]) &#123; ++x; &#125; else if(i &gt; 0 &amp;&amp; numbers[i-1]) &#123; if(numbers[i] == numbers[i-1]) &#123; return false; &#125; y += numbers[i] - numbers[i-1] - 1; &#125; &#125; return x &gt;= y; &#125;&#125;; 圆圈中最后剩下的数 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 1234567891011121314class Solution &#123;public: int LastRemaining_Solution(int n, int m) &#123; if(n &lt; 1 || m &lt; 1) &#123; return -1; &#125; int last = 0; for(int i = 2; i &lt;= n; ++i) &#123; last = (last+m)%i; &#125; return last; &#125;&#125;; 求1+2+3+…+n 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 123456789101112class Solution &#123;public: typedef int (*func)(int); static int Sum_Solution_Zero(int n) &#123; return 0; &#125; static int Sum_Solution(int n) &#123; static func f[2] = &#123;Sum_Solution_Zero, Sum_Solution&#125;; return f[!!n](n-1) + n; &#125;&#125;; 不用加减乘除做加法 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 12345678910111213class Solution &#123;public: int Add(int num1, int num2) &#123; while(num2) &#123; int sum = num1 ^ num2; int carry = (num1 &amp; num2) &lt;&lt; 1; num1 = sum; num2 = carry; &#125; return num1; &#125;&#125;; 把字符串转换为整数 将一个字符串转换成一个整数(实现Integer.valueOf(string)的功能，但是string不符合数字要求时返回0)，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0。 123456789101112131415161718192021222324class Solution &#123;public: int StrToInt(string str) &#123; if(str.empty()) &#123; return 0; &#125; int ans = 0, pos = 0, neg = 1; while(pos &lt; str.size() &amp;&amp; str[pos] == ' ') ++pos; if(pos &lt; str.size()) &#123; if(str[pos] == '-') &#123; neg = -1; ++pos; &#125; else if(str[pos] == '+') &#123; ++pos; &#125; &#125; while(pos &lt; str.size() &amp;&amp; str[pos] &gt;= '0' &amp;&amp; str[pos] &lt;= '9') &#123; ans = ans*10 + str[pos] - '0'; ++pos; &#125; return pos == str.size() ? neg*ans : 0; &#125;&#125;; 数组中重复的数字 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 123456789101112131415161718192021222324252627282930class Solution &#123;public: // Parameters: // numbers: an array of integers // length: the length of array numbers // duplication: (Output) the duplicated number in the array number // Return value: true if the input is valid, and there are some duplications // in the array number otherwise false bool duplicate(int numbers[], int length, int* duplication) &#123; int ans = -1, start = 0; while(start &lt; length) &#123; while(numbers[start] &lt; length &amp;&amp; numbers[start] != start) &#123; int temp = numbers[start]; if(numbers[start] == numbers[temp]) &#123; *duplication = numbers[start]; return true; &#125; numbers[start] = numbers[temp]; numbers[temp] = temp; &#125; if(numbers[start] &gt;= length) &#123; return false; &#125; ++start; &#125; return false; &#125; // 如果是总共 n 个数，所有的数都是在 1~n-1 的范围内才可以用二分 // 例如 2 1 3 1 4， 假定数字范围为 0 ~ 4, 则第一次二分出 0~2 有3个，那么下一步搜索 3~4，不会找到1&#125;; 构建乘积数组 给定一个数组A[0,1,...,n-1],请构建一个数组B[0,1,...,n-1],其中B中的元素B[i]=A[0]*A[1]*...*A[i-1]*A[i+1]*...*A[n-1]。不能使用除法。 12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; multiply(const vector&lt;int&gt;&amp; A) &#123; vector&lt;int&gt; B; if(A.size() &lt; 2) &#123; return A; &#125; B.push_back(1); for(int i = 1; i &lt; A.size(); ++i) &#123; B.push_back(B.back()*A[i-1]); &#125; int last = A.back(); for(int i = A.size()-2; i &gt;= 0; --i) &#123; B[i] *= last; last *= A[i]; &#125; return B; &#125;&#125;; 正则表达式匹配 请实现一个函数用来匹配包括&#39;.&#39;和&#39;*&#39;的正则表达式。模式中的字符’.’表示任意一个字符，而&#39;*&#39;表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串&quot;aaa&quot;与模式&quot;a.a&quot;和&quot;ab*ac*a&quot;匹配，但是与&quot;aa.a&quot;和&quot;ab*a&quot;均不匹配 12345678910111213141516171819202122class Solution &#123;public: bool match(char* str, char* pattern) &#123; int n = strlen(str), m = strlen(pattern); bool dp[2][m+1]; dp[n%2][m] = true; for(int i = n; i &gt;= 0; --i) &#123; for(int j = m; j &gt;= 0; --j) &#123; if(i == n &amp;&amp; j == m) continue; bool is_match = i &lt; n &amp;&amp; j &lt; m &amp;&amp; (str[i] == pattern[j] || pattern[j] == '.'); if(j &lt; m-1 &amp;&amp; pattern[j+1] == '*') &#123; dp[i%2][j] = dp[i%2][j+2] || (is_match &amp;&amp; dp[(i+1)%2][j]); &#125; else &#123; dp[i%2][j] = is_match &amp;&amp; dp[(i+1)%2][j+1]; &#125; &#125; &#125; return dp[0][0]; &#125;&#125;; 表示数值的字符串 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串&quot;+100&quot;,&quot;5e2&quot;,&quot;-123&quot;,&quot;3.1416&quot;和&quot;-1E-16&quot;都表示数值。 但是&quot;12e&quot;,&quot;1a3.14&quot;,&quot;1.2.3&quot;,&quot;+-5&quot;和&quot;12e+4.3&quot;都不是。 123456789101112131415161718192021222324252627class Solution &#123;public: bool isNumeric(char* string) &#123; int n = strlen(string); bool has_e = false, has_dot = false; for(int i = 0; i &lt; n; ++i) &#123; if(string[i] == 'e' || string[i] == 'E') &#123; if(has_e || i == n-1) return false; has_e = true; &#125; else if(string[i] == '.') &#123; if(has_dot || has_e) return false; has_dot = true; &#125; else if(string[i] == '+' || string[i] == '-') &#123; if(i &gt; 0 &amp;&amp; !has_e) return false; if(has_e &amp;&amp; string[i-1] != 'e' &amp;&amp; string[i-1] != 'E') return false; &#125; else if(string[i] &gt; '9' || string[i] &lt; '0') &#123; return false; &#125; &#125; return true; &#125;&#125;; 字符流中第一个不重复的字符 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符&quot;go&quot;时，第一个只出现一次的字符是&quot;g&quot;。当从该字符流中读出前六个字符“google&quot;时，第一个只出现一次的字符是&quot;l&quot;。 1234567891011121314151617181920212223242526272829303132333435class Solution&#123;public: Solution() &#123; memset(char_pos, 0, sizeof(int)*256); cnt = 1; &#125; //Insert one char from stringstream void Insert(char ch) &#123; if(char_pos[ch] &gt; 0) char_pos[ch] = -1; else if(char_pos[ch] == 0) &#123; char_pos[ch] = cnt++; &#125; &#125; //return the first appearence once char in current stringstream char FirstAppearingOnce() &#123; int min_pos = INT_MAX; char ans; for(int i = 0; i &lt; 256; ++i) &#123; if(char_pos[i] &gt; 0 &amp;&amp; min_pos &gt; char_pos[i]) &#123; min_pos = char_pos[i]; ans = (i+'\0'); // or ` ans = i ` is ok &#125; &#125; if(min_pos == INT_MAX) return '#'; return ans; &#125;private: int char_pos[256]; int cnt;&#125;; 链表环中的入口节点 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* FindMeetingNode(ListNode* pHead) &#123; ListNode* pslow = pHead; ListNode* pfast = pHead-&gt;next; while(pslow &amp;&amp; pfast &amp;&amp; pslow != pfast) &#123; pslow = pslow-&gt;next; pfast = pfast-&gt;next; if(pfast) &#123; pfast = pfast-&gt;next; &#125; &#125; if(pslow &amp;&amp; pfast &amp;&amp; pslow == pfast) &#123; return pslow; &#125; return nullptr; &#125; ListNode* EntryNodeOfLoop(ListNode* pHead) &#123; if(!pHead || pHead-&gt;next == nullptr) &#123; return nullptr; &#125; ListNode* meeting_node = FindMeetingNode(pHead); if(!meeting_node) &#123; return nullptr; &#125; int num_in_loop = 1; ListNode* temp_node = meeting_node-&gt;next; while(temp_node != meeting_node) &#123; temp_node = temp_node-&gt;next; ++num_in_loop; &#125; temp_node = pHead; while(num_in_loop--) &#123; temp_node = temp_node-&gt;next; &#125; ListNode* temp_node2 = pHead; while(temp_node != temp_node2) &#123; temp_node = temp_node-&gt;next; temp_node2 = temp_node2-&gt;next;; &#125; return temp_node; &#125;&#125;; 删除链表中重复的节点 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 1234567891011121314151617181920212223242526272829303132333435/*struct ListNode &#123; int val; struct ListNode *next; ListNode(int x) : val(x), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: ListNode* deleteDuplication(ListNode* pHead) &#123; if(!pHead || pHead-&gt;next == nullptr) &#123; return pHead; &#125; ListNode* temp_head = new ListNode(-1); temp_head-&gt;next = pHead; ListNode* first = temp_head; ListNode* second = temp_head-&gt;next; while(second) &#123; if(second-&gt;next &amp;&amp; second-&gt;val == second-&gt;next-&gt;val) &#123; while(second-&gt;next &amp;&amp; second-&gt;val == second-&gt;next-&gt;val) &#123; second = second-&gt;next; &#125; first-&gt;next = second-&gt;next; &#125; else &#123; first = first-&gt;next; &#125; second = second-&gt;next; &#125; return temp_head-&gt;next; &#125;&#125;; 二叉树的下一个节点 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 123456789101112131415161718192021222324252627282930313233343536373839404142/*struct TreeLinkNode &#123; int val; struct TreeLinkNode *left; struct TreeLinkNode *right; struct TreeLinkNode *next; TreeLinkNode(int x) :val(x), left(NULL), right(NULL), next(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeLinkNode* GetNext(TreeLinkNode* pNode) &#123; if(!pNode) &#123; return nullptr; &#125; if(pNode-&gt;right) &#123; pNode = pNode-&gt;right; while(pNode &amp;&amp; pNode-&gt;left) &#123; pNode = pNode-&gt;left; &#125; return pNode; &#125; if(pNode-&gt;next) &#123; if(pNode-&gt;next-&gt;left == pNode) &#123; return pNode-&gt;next; &#125; TreeLinkNode* fa = pNode-&gt;next; while(pNode &amp;&amp; fa &amp;&amp; fa-&gt;left != pNode) &#123; pNode = fa; fa = fa-&gt;next; &#125; if(fa &amp;&amp; fa-&gt;left == pNode) &#123; return fa; &#125; return nullptr; &#125; return nullptr; &#125;&#125;; 对称的二叉树 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 1234567891011121314151617181920212223242526272829303132/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: bool isSymmetricalCore(TreeNode* pleft, TreeNode* pright) &#123; if(!pleft || !pright) &#123; return !pleft &amp;&amp; !pright; &#125; if(pleft-&gt;val == pright-&gt;val) &#123; return isSymmetricalCore(pleft-&gt;left, pright-&gt;right) &amp;&amp; isSymmetricalCore(pleft-&gt;right, pright-&gt;left); &#125; return false; &#125; bool isSymmetrical(TreeNode* pRoot) &#123; if(!pRoot) &#123; return true; &#125; return isSymmetricalCore(pRoot-&gt;left, pRoot-&gt;right); &#125;&#125;; 按之字形顺序打印二叉树 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; ans; if(!pRoot) &#123; return ans; &#125; deque&lt;TreeNode*&gt; que[2]; int index = 0; que[index].push_back(pRoot); vector&lt;int&gt; line; while(!que[index].empty()) &#123; TreeNode* head = nullptr; if(index) &#123; head = que[index].back(); line.push_back(head-&gt;val); que[index].pop_back(); if(head-&gt;right) &#123; que[1-index].push_back(head-&gt;right); &#125; if(head-&gt;left) &#123; que[1-index].push_back(head-&gt;left); &#125; &#125; else &#123; head = que[index].back(); line.push_back(head-&gt;val); que[index].pop_back(); if(head-&gt;left) &#123; que[1-index].push_back(head-&gt;left); &#125; if(head-&gt;right) &#123; que[1-index].push_back(head-&gt;right); &#125; &#125; if(que[index].empty()) &#123; index = 1 - index; ans.push_back(line); line.clear(); &#125; &#125; return ans; &#125; &#125;; 把二叉树打印成多行 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 123456789101112131415161718192021222324252627282930313233343536373839404142/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: vector&lt;vector&lt;int&gt; &gt; Print(TreeNode* pRoot) &#123; vector&lt;vector&lt;int&gt; &gt; ans; if(!pRoot) &#123; return ans; &#125; queue&lt;TreeNode*&gt; que; que.push(pRoot); int cnt = 1; vector&lt;int&gt; temp_ans; while(!que.empty()) &#123; TreeNode* temp_node = que.front(); temp_ans.push_back(temp_node-&gt;val); que.pop(); if(temp_node-&gt;left) &#123; que.push(temp_node-&gt;left); &#125; if(temp_node-&gt;right) &#123; que.push(temp_node-&gt;right); &#125; --cnt; if(cnt == 0) &#123; ans.push_back(temp_ans); temp_ans.clear(); cnt = que.size(); &#125; &#125; return ans; &#125; &#125;; 序列化二叉树 请实现两个函数，分别用来序列化和反序列化二叉树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: void SerializeCore(TreeNode *root, string&amp; ans) &#123; if(!root) &#123; ans += "$,"; return; &#125; ans += to_string(root-&gt;val) + ","; SerializeCore(root-&gt;left, ans); SerializeCore(root-&gt;right, ans); &#125; char* Serialize(TreeNode *root) &#123; string ans; SerializeCore(root, ans); char *ansp = new char[ans.length()]; memcpy(ansp, ans.c_str(), ans.length()); return ansp; &#125; bool ReadNumber(char *str, int&amp; pos, int&amp; number) &#123; number = 0; bool has_num = false; while(str[pos]) &#123; if(str[pos] &gt;= '0' &amp;&amp; str[pos] &lt;= '9') &#123; number = number*10 + (str[pos] - '0'); has_num = true; ++pos; &#125; else if(str[pos] == ',') &#123; ++pos; break; &#125; else if(str[pos] == '$') &#123; ++pos; &#125; &#125; return has_num; &#125; void DeserializeCore(TreeNode** root, char *str, int&amp; pos) &#123; int number; if(ReadNumber(str, pos, number)) &#123; (*root) = new TreeNode(number); DeserializeCore(&amp;((*root)-&gt;left), str, pos); DeserializeCore(&amp;((*root)-&gt;right), str, pos); &#125; &#125; TreeNode* Deserialize(char *str) &#123; TreeNode* ans = nullptr; if(!str || str[0] == '$') &#123; return ans; &#125; int pos = 0; DeserializeCore(&amp;ans, str, pos); return ans; &#125;&#125;; 二叉搜索树的第k个节点 给定一棵二叉搜索树，请找出其中的第k小的结点。例如，（5，3，7，2，4，6，8）中，按结点数值大小顺序第三小结点的值为4。 12345678910111213141516171819202122232425262728293031323334353637/*struct TreeNode &#123; int val; struct TreeNode *left; struct TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) &#123; &#125;&#125;;*/class Solution &#123;public: TreeNode* KthNodeCore(TreeNode* pRoot, int&amp; k) &#123; TreeNode* target = nullptr; if(pRoot-&gt;left) &#123; target = KthNodeCore(pRoot-&gt;left, k); &#125; if(target == nullptr) &#123; if(k == 1) &#123; target = pRoot; &#125; --k; &#125; if(target == nullptr &amp;&amp; pRoot-&gt;right) &#123; target = KthNodeCore(pRoot-&gt;right, k); &#125; return target; &#125; TreeNode* KthNode(TreeNode* pRoot, int k) &#123; if(!pRoot || !k) &#123; return nullptr; &#125; return KthNodeCore(pRoot, k); &#125;&#125;; 数据流中的中位数 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: void Insert(int num) &#123; if(min_half_.size() &lt;= max_half_.size()) &#123; if(max_half_.size() &gt; 0 &amp;&amp; num &lt; max_half_.top()) &#123; max_half_.push(num); num = max_half_.top(); max_half_.pop(); &#125; min_half_.push(num); &#125; else &#123; if(min_half_.size() &gt; 0 &amp;&amp; num &gt; min_half_.top()) &#123; min_half_.push(num); num = min_half_.top(); min_half_.pop(); &#125; max_half_.push(num); &#125; &#125; double GetMedian() &#123; if((min_half_.size() + max_half_.size())%2) &#123; return min_half_.top(); &#125; else if(!min_half_.empty()) &#123; return (min_half_.top() + max_half_.top())/2.0; &#125; return 0.0; &#125; private: priority_queue&lt;int, std::vector&lt;int&gt; ,std::greater&lt;int&gt; &gt; min_half_; priority_queue&lt;int&gt; max_half_;&#125;; 滑动窗口的最大值 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; maxInWindows(const vector&lt;int&gt;&amp; num, unsigned int size) &#123; vector&lt;int&gt; ans; if(size == 0 || num.empty()) &#123; return ans; &#125; deque&lt;int&gt; que; // 表示下标，如果直接用数字 7 2 5 6 1, size = 3 时会有问题。 for(int i = 0; i &lt; num.size(); ++i) &#123; while(!que.empty() &amp;&amp; num[que.back()] &lt;= num[i]) &#123; que.pop_back(); &#125; while(!que.empty() &amp;&amp; i-que.front() &gt; size-1) &#123; que.pop_front(); &#125; que.push_back(i); if(i &gt;= size-1) &#123; ans.push_back(num[que.front()]); &#125; &#125; return ans; &#125;&#125;; 矩阵中的路径 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: bool hasPathCore(char* matrix, int rows, int cols, char* str, bool* visited, int x, int y, int pos) &#123; if(str[pos] == '\0') &#123; return true; &#125; bool hasPath = false; if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &lt; cols &amp;&amp; matrix[x*cols+y] == str[pos] &amp;&amp; !visited[x*cols+y]) &#123; ++pos; visited[x*cols+y] = true; hasPath = hasPathCore(matrix, rows, cols, str, visited, x+1, y, pos) || hasPathCore(matrix, rows, cols, str, visited, x, y+1, pos) || hasPathCore(matrix, rows, cols, str, visited, x, y-1, pos) || hasPathCore(matrix, rows, cols, str, visited, x-1, y, pos); if(!hasPath) &#123; --pos; visited[x*cols+y] = false; &#125; &#125; return hasPath; &#125; bool hasPath(char* matrix, int rows, int cols, char* str) &#123; if(!matrix || !str) &#123; return false; &#125; bool* visited = new bool[rows*cols]; memset(visited, 0, rows*cols); for(int i = 0; i &lt; rows; ++i) &#123; for(int j = 0; j &lt; cols; ++j) &#123; if(hasPathCore(matrix, rows, cols, str, visited, i, j, 0)) &#123; return true; &#125; &#125; &#125; delete[] visited; return false; &#125;&#125;; 机器人的运动范围 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: int digitSum(int x, int y) &#123; int ans = 0; while(x) &#123; ans += (x%10); x /= 10; &#125; while(y) &#123; ans += (y%10); y /= 10; &#125; return ans; &#125; int movingCountCore(int threshold, int rows, int cols, int x, int y, bool* visited) &#123; int count = 0; if(x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &lt; cols &amp;&amp; digitSum(x, y) &lt;= threshold &amp;&amp; !visited[x*cols+y]) &#123; visited[x*cols+y] = true; count = 1 + movingCountCore(threshold, rows, cols, x-1, y, visited) + movingCountCore(threshold, rows, cols, x, y-1, visited) + movingCountCore(threshold, rows, cols, x+1, y, visited) + movingCountCore(threshold, rows, cols, x, y+1, visited); &#125; return count; &#125; int movingCount(int threshold, int rows, int cols) &#123; if(threshold &lt; 0 || rows &lt;= 0 || cols &lt;= 0) &#123; return 0; &#125; bool* visited = new bool[rows*cols]; memset(visited, 0, rows*cols); int count = movingCountCore(threshold, rows, cols, 0, 0, visited); delete[] visited; return count; &#125;&#125;;]]></content>
      <categories>
        <category>algorithms</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[epoll源码]]></title>
    <url>%2Fepoll%2Fepoll.html</url>
    <content type="text"><![CDATA[epoll 内部监听的事件以epitem组织为一个红黑树 注册和事件添加到epoll的rdlist都是通过调用f_op-&gt;poll 注册时是通过将epoll添加到文件的wait_queue_head中 rdlist上的epitem通常是由被监听文件自己挂上去的 data struct fs/eventpoll.c epoll_create (SYSCALL_DEFINE1(epoll_create) -&gt; do_epoll_create 123456789101112131415161718192021222324252627282930313233343536373839404142// 有 strcstruct eventpoll &#123; spinlock_t lock; // 保护对eventpoll的访问 struct mutex mtx; // ctl 和 事件收集时用到 /* Wait queue used by sys_epoll_wait() */ wait_queue_head_t wq; /* Wait queue used by file-&gt;poll() */ wait_queue_head_t poll_wait; struct file *file; struct list_head rdllist; // 所有 ready 的 fd struct rb_root_cached rbr; // 所有 add 进来的 fd -&gt; epitem struct epitem *ovflist; // 单项链表存储所有 epitem&#125;;struct epoll_event &#123; __poll_t events; __u64 data;&#125; EPOLL_PACKED;struct epoll_filefd &#123; struct file *file; int fd;&#125; __packed;struct eppoll_entry &#123; struct list_head llink; // 指向 epitem 中的 pwqlist，从而将 epitem 连成链表 struct epitem *base; // 指向所属的 epitem wait_queue_entry_t wait; // 要加入被监听文件的wait_queue的回调函数 wait_queue_head_t *whead;&#125;;struct epitem &#123; struct eventpoll *ep; // 指向所属的 eventpoll /* The file descriptor information this item refers to */ struct epoll_filefd ffd; // epitem 对应的 struct file 和 fd struct list_head fllink; // epitem 中的 struct file 通过这个组织成一个链表 struct list_head pwqlist; // poll wait queues，指向 epoll_entry 中的 llink struct epoll_event event;&#125;; 相关的数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct wait_queue_head &#123; spinlock_t lock; struct list_head head;&#125;;typedef struct wait_queue_head wait_queue_head_t;struct mutex &#123; atomic_long_t owner; spinlock_t wait_lock; struct optimistic_spin_queue osq; // 优化 mutex 的性能 struct list_head wait_list;&#125;;/* * Leftmost-cached rbtrees. * * We do not cache the rightmost node based on footprint * size vs number of potential users that could benefit * from O(1) rb_last(). Just not worth it, users that want * this feature can always implement the logic explicitly. * Furthermore, users that want to cache both pointers may * find it a bit asymmetric, but that's ok. */struct rb_root_cached &#123; struct rb_root rb_root; struct rb_node *rb_leftmost;&#125;;struct file &#123; struct path f_path; struct inode *f_inode; /* cached value */ const struct file_operations *f_op; spinlock_t f_lock; // 对于epollfd指向 struct event_poll void *private_data; #ifdef CONFIG_EPOLL /* Used by fs/eventpoll.c to link all the hooks to this file */ struct list_head f_ep_links; // 所有监听此文件的 epitem 的链表 struct list_head f_tfile_llink; #endif /* #ifdef CONFIG_EPOLL */ // ....&#125;;struct callback_head &#123; struct callback_head *next; void (*func)(struct callback_head *head);&#125; __attribute__((aligned(sizeof(void *))));#define rcu_head callback_head epoll_create glibc的epoll_create -&gt; 系统调用的epoll_create -&gt; do_epoll_create ep_alloc(&amp;ep) 创建一个 struct eventpoll 即 ep，并初始化 fd = get_unused_fd_flags 获取一个可用的fd file = anon_inode_getfile(&quot;[eventpoll]&quot;, &amp;eventpoll_fops, ep,O_RDWR | (flags &amp; O_CLOEXEC)); 创建一个名为[eventpoll]的匿名文件，文件的fop设置为eventpoll_fops（staic全局变量） file-&gt;private_data = ep fd_install(fd, file); 使 task_struct-&gt;files-&gt;fdt-&gt;fd[fd] = file eventpoll_fops-&gt;poll = ep_eventpoll_poll poll函数用于驱动提供给应用程序探测设备文件是否可读或可写。当该函数指针为空时表示设备可对文件非阻塞的读写。调用poll函数的进程会sleep知道可读或可写。 epoll_ctl 根据参数分别调用ep_insert，ep_remove，ep_modify。 ADD： epoll_ctl在ADD时会调用对监听fd的f_op-&gt;poll，里面将调用poll_wait创建一个wait_queue_entry，内含一个回调函数（在poll_table中 ），将此wait_queue_entry挂到被监听fd的wait_queue_head上，当设备对此fd进行读写时会唤醒被监听fd的wait_queue_head上监听对应事件的进行，调用注册进来的回调函数。 epoll使用红黑树管理它监听的所有文件，它为每个监听的文件创建一个epitem，加入到eventpoll的rbr字段（红黑树root）中。 如果要监听的是一个非epoll文件，内核会调用epfd的f_op-&gt;poll回调，内核创建一个epoll_entry，通过调用该回调函数，将epoll_entry加入到文件内部的wait_queue_head中，以便文件有事件到达时通过该epoll_entry，将对应的epitem加入到eventpoll的rdlist中。 如果要监听的是一个epoll文件，epfd2对应的eventpoll结构体中有一个wait_queue_head——poll_wait。因此，内核同样会创建一个epoll_entry，然后将该epoll_entry加入到poll_wait中，以便epfd2通知epfd1。 epoll_wait 如果eventpoll的rdlist中没有epollitem，则说明监听的文件没有一个事件到达，这时需要将当前文件陷入阻塞（睡在eventpoll-&gt;wq上），等待有任意事件到达。 如果有事件到达，则将rdlist中所有的epollitem一口气取下来，放到一个临时链表中（避免争用rdlist）。对于临时链表中的每一项epollitem： 将epollitem从链表中取下 调用ep_item_poll 如果epitem对应的是一个非epoll文件，调用它的f_op-&gt;poll回调，获取该文件的事件，与epitem记录的要等待的事件取与。若取与得到的值不为0， 说明确实有要等待的事件发生，首先将该事件拷贝到用户缓冲区 然后，如果是EPOLLONESHOT，则在拷贝完事件后去掉对EPOLLIN/EPOLLOUT等的监听，只保留EPOLLWAKEUP | EPOLLONESHOT | EPOLLET | EPOLLEXCLUSIVE四个标志位的值。 然后，如果是水平触发模式，则将该epollitem再放到eventpoll的尾部。 如果epitem对应的是一个epoll文件（称为epfd2），则以epfd2为参数，递归进入第二项判断rdlist。 如果从临时链表中取出了用户要求的最大事件数，则停止循环 现在，将临时链表中剩下的没有处理完的那些事件重新加到rdlist中。 如果rdlist中有还没有处理完的数据，唤醒睡在eventpoll-&gt;wq上的进程（处于epoll_wait阻塞的进程），并通知eventpoll-&gt;poll_wait上的进程（比如epfd1监听epfd2，那么epfd2会通过自己的poll_wait通知epfd1，这会导致epfd1的rdlist中出现一项关于epfd2的epollitem）。 如果发现没有拿到任何事件（到达的事件和想要的事件不同，或者被其他进程提前一步拿走了），且还没有超过epoll_wait限制的时间，则跳转到第一步重新开始。 通过上面的流程描述，可以知道，水平触发模式的文件，在缓冲区有数据时，会一直待在rdlist中，直到它的缓冲区数据为空。 需要注意的是，rdlist上的epitem通常是由被监听文件自己挂上去的。比如，当监听一个管道时，管道文件自己有一个wait_queue_head，当我们将管道文件通过EPOLL_ADD加入到epoll中时，会调用一次管道文件的poll回调。poll回调通过调用poll_wait函数，将我们的epoll注册到它自己的wait_queue_head中。然后，当管道文件发现自己缓冲区可读可写时，它会通过自己的wait_queue_head通知epoll，将epitem挂在epoll的rdlist里面。这样，当epoll_wait被调用时，就会发现自己的rdlist里面有数据，然后，它会遍历rdlist中的每一项，对每一项调用poll回调，这样，管道的poll回调又一次被调用了。不过，这一次管道并不会将epoll注册到自己的wait_queue_head中去，它仅仅判断自己的缓冲区的可读可写事件，返回对于的POLLIN/POLLOUT，然后，epoll_wait根据返回的事件，与要监听的事件做与操作，来决定是否拷贝该事件。 select123456int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);// 默认 #define __FD_SETSIZE 1024void FD_CLR(int fd, fd_set *set);int FD_ISSET(int fd, fd_set *set);void FD_SET(int fd, fd_set *set);void FD_ZERO(fd_set *set); 调用过程：select -&gt; kern_select -&gt; core_sys_select 对于每个fd，如果在读/写/异常fd_set中的任意一个fd_set中置位了 调用fd对于file的f_op-&gt;poll回调 如果poll_table中有回调函数，它将负责创建一个wait_queue_entry，并将该entry挂在file提供的wait_queue_head中。然后，poll回调函数还将返回文件的状态（POLLIN/POLLOUT/…） 如果poll_table没有回调函数，则poll回调仅仅返回文件的状态 根据poll回调返回的文件状态，判断返回状态是否为想要监听的状态。比如返回了POLLIN，且fd恰好在读的fd_set中，则在返回给用户的读fd_set中，标记该位，然后将poll_table的回调置为NULL。这一步很重要，因为它会导致后续对fd的f_op-&gt;poll回调不再挂任何wait_queue_entry到剩下的fd的wait_queue_head中。 当对于所有的fd都判断完毕后 如果得到了想要监听的事件，那么就取下那些之前遍历时挂上去的wait_queue_entry，然后将对应的事件拷贝给用户。 如果超时了，那么操作和上面一样 否则，说明没有任何想要的事件达到，而且我们已经将wait_queue_entry挂在了每个想要监听的文件的wait_queue_head上。现在，根据select传递进来的超时时间，陷入一定时间的睡眠，等待被超时唤醒，或者被监听文件唤醒，然后重复第一步。 struct timeval *timeout内的内容会经历从用户态拷贝到内核再拷贝回来的过程。 select只有一个系统调用，而不像epoll拥有三个系统调用。因此，select对事件的监听没有像epoll那样，做到常驻内核。 在使用select时，需要传递三个fd_set，fd_set实际上是关于fd的位图，所有需要监听的fd对于的位被置1。三个fd_set分别对应读/写/异常事件的监听 select 和 epoll 对比 select比epoll慢的主要原因： 对fd_set的拷贝开销：三个fd_set，不管结果成功与否，都要进行拷贝。 没有常驻内核：每次调用select都需要重新挂wait_queue_entry，离开时还需要给取下来。 另外，由于select是位图，所以允许监听的最大fd数量是有限制的，而epoll使用红黑树，它可以监听更多的fd。 problems spinlock_t在4.2之后内部实现改为了qspinlock struct mutex的trylock调用了atomic_long_try_cmpxchg_acquire+ `struct optimistic_spin_queue osq;`的作用 rcu机制]]></content>
      <categories>
        <category>epoll</category>
      </categories>
      <tags>
        <tag>os</tag>
        <tag>network</tag>
        <tag>source code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[os]]></title>
    <url>%2Fcat%2Fos.html</url>
    <content type="text"><![CDATA[1. Course MIT 6.828 ustc os ustc linux操作系统分析 stanford cs240 cmu 15410 2. 系统启动 现代计算机使用UEFI，可以一次加载超过512B的boot sector。 以下为JOS启动流程。 计算机通电后先读取BIOS，加载到960KB~1MB地址出。 BIOS进行硬件自检，同时打印硬件信息在屏幕上。有问题蜂鸣器会响。 之后计算机读取BIOS设置好的优先级最高的外部存储设备。读取第一个扇区（512字节，即主引导记录MBR）到0x7c00处。如果这个扇区最后两个字节是0x55和0XAA表明可以启动，否则不能。 主引导记录即boot.S，其中的主要流程包括： 关中断，开A20线（兼容性问题，寻找范围更大），加载段表(lgdt gdtdesc)（包含操作系统内核的段信息），寻址方式变为segment:offset 设置CR0寄存器的CR0_PE_ON为1：从实模式（16bit寻址）切换到保护模式（32bit寻址） 实模式下寻址方式：物理地址 = 段基址&lt;&lt;4 + 段内偏移，早期寄存器是16位，地址线是20位，只能访问1MB 例如：%cs = xff00，%ax = 0x0110，则物理地址为：0xff00&lt;&lt;4 + 0x0110 = 0xff110 保护模式下寻址方式：segment:offset，segment找到该段的基址base，（检查flags可访问的话）之后直接与offset相加得到线性地址，如果没有分页则线性地址等于物理地址。 程序员看到的是虚拟地址，但指令中出现的是逻辑地址即segment:offset 跳转到保护模式代码段，该段主要执行： 设置各寄存器的值，包括cs指令地址，ds数据段地址，ss栈指针等，jos设置其指向0x7c00 call bootmain：即boot/main.c中的代码 bootmain的主要工作： 将硬盘上的kernel加载到内存里的0x10000处，其中.text段在0x100000处。并执行ELFHDR-&gt;e_entry(0x10000C处，boot/entry.S)。内核映像为ELF格式。 entry处的代码主要：这是CR3寄存器，开启分页，设置内核堆栈的起始地址（0xf0110000），之后call i386_init 3. 内存管理3.1、分页 JOS采用二级页表，CR3指向page dircectory，虚拟地址高10位查找page dircectory中的Page Table Entry（PTE），每个PTE存放了一个页地址的高20位，PTE的低12位用作标志位，物理地址的低12位是从原虚拟地址直接拷贝过来的。 现代X86是flat模式，即只有一个段，即段基址为0，所以虚拟地址=线性地址。 在平坦模式下，段机制在两个地方会被用上，一个是per-cpu变量（内核开发中使用），另一个是线程局部存储（用户态开发中使用），它们分别会用到gs段和fs段。 现代X86是四级页表。 32位三级页表 PDE和PTE的每一项为32位。PD和PT的大小为4K。 这种模式下仅能访问到4G的物理地址空间，应用程序和内核能用到的线性地址空间为4G。 32位PAE模式 PDE和PTE的每一项为64位。PD和PT的大小为4K 这种模式下能访问到64G的物理地址空间，应用程序和内核能用到的线性地址空间为4G X86_64（IA32E/AMD64）下的4级页表 PDE和PTE的每一项为64位。PD和PT的大小为4K 理论上，这种模式下能访问到2^64大小的物理地址空间，应用程序和内核能用到的线性地址空间为2^64。实际上，能访问的线性地址空间大小为2^48次方。 在linux内核中，这四级页表分别被称为PGD、PUD、PMD、PT。 PTE项各字段的作用 P位，表示PTE指向的物理内存是否存在(Present)，这可以用于标识物理页面是否被换出 R/W位，表示这个页是否是可读/可写的。这可以用于fork的cow机制 D位，表示这个页是否是脏页。一旦有数据写入到这个页面，CPU会自动将这个位置位。这可以用来在内核做页面回收及换入换出时，判断是否需要将这个页的数据写入到磁盘中。（实际的实现机制不清楚，但理论上是可以的） U/S位，表示这个页面是否能够在用户态下被访问，内核通过此位来识别用户空间或内核空间的页 CPL（current privilege level），用两位表示，分别对应0-3共四个级别，放在CS段选择子的低两位，表示当前的运行等级（ring0-ring3）CPL&lt;3为supervisor模式，CPL=3为user模式 在用户态下，访问U/S位为0的页将引起page fault，这用来阻止用户程序对内核空间的非法访问。 3.2、页框管理 页框号pfn与struct page之间的转换，配置了SPARSEMEM_VMEMMAP的情况下： 12345678910111213141516// 此处相当于做了一个优化，加速转换，但是mem_section还是存在的#if defined(CONFIG_SPARSEMEM_VMEMMAP) #define __pfn_to_page(pfn) (vmemmap + (pfn))#define __page_to_pfn(page) (unsigned long)((page) - vmemmap)#elif defined(CONFIG_SPARSEMEM)#define __page_to_pfn(pg) \(&#123; const struct page *__pg = (pg); \ int __sec = page_to_section(__pg); \ (unsigned long)(__pg - __section_mem_map_addr(__nr_to_section(__sec))); \&#125;)#define __pfn_to_page(pfn) \(&#123; unsigned long __pfn = (pfn); \ struct mem_section *__sec = __pfn_to_section(__pfn); \ __section_mem_map_addr(__sec) + __pfn; \&#125;) 1234567891011121314#define NR_SECTION_ROOTS DIV_ROUND_UP(NR_MEM_SECTIONS, SECTIONS_PER_ROOT) //1&lt;&lt;(19/8)=2k#define SECTIONS_SHIFT (MAX_PHYSMEM_BITS - SECTION_SIZE_BITS) // 46 - 27 = 19#define NR_MEM_SECTIONS (1UL &lt;&lt; SECTIONS_SHIFT) // 1 &lt;&lt; 19#define SECTIONS_PER_ROOT (PAGE_SIZE / sizeof (struct mem_section)) // 4k/16 = 256// SECTION_SIZE_BITS 为 27 表示每个 section 为 128Mstruct mem_section &#123; unsigned long section_mem_map; unsigned long *pageblock_flags;&#125;;#define PAGES_PER_SECTION (1UL &lt;&lt; PFN_SECTION_SHIFT) // 1 &lt;&lt; 15 = 32k#define PFN_SECTION_SHIFT (SECTION_SIZE_BITS - PAGE_SHIFT) // 27 - 12 = 15// 即每个 section 管理 32k * 4k = 128M 的物理内存// 每个 struct pages 大小为 64B, 即每个 section 所存的 struct page 数组的大小为 32k*64B = 2M 12345678910111213141516171819202122232425262728293031323334// 全局的，每个 NUMA 节点一个 pglist_datastruct pglist_data *node_data[MAX_NUMNODES] __read_mostly; #define MAX_NUMNODES (1 &lt;&lt; NODES_SHIFT) #define NODES_SHIFT CONFIG_NODES_SHIFT // 自己的服务器上为 10， 阿里云单核为 4 ？#define MAX_NR_ZONES 5// MAX_ZONELISTS 为 1, NUMA下 为 2, 本节点的 node_zonelists 不够可使用备用的 node_zonelists 分配typedef struct pglist_data &#123; struct zone node_zones[MAX_NR_ZONES]; struct zonelist node_zonelists[MAX_ZONELISTS]; int nr_zones; unsigned long node_start_pfn; unsigned long node_present_pages; /* total number of physical pages */ /* total size of physical page range, including holes */ unsigned long node_spanned_pages; int node_id;&#125;pg_data_t;struct zone &#123; struct free_area free_area[MAX_ORDER]; // 每个 free_area 即伙伴系统的一个2^i个连续页框的节点&#125; enum zone_type &#123; ZONE_DMA, ZONE_DMA32, ZONE_NORMAL, ZONE_HIGHMEM, ZONE_MOVABLE, ZONE_DEVICE, __MAX_NR_ZONES&#125;;// strcut page 中的 flags 成员中的某些位可以反推出该 page 属于哪一个 node 及哪一个 zone// 每个zone中都有 3.3、buddy系统 用于管理页框缓冲池，解决频繁申请不同大小的连续页框导致的外部碎片问题。 把所有的空闲页框组织为11个块链表：每个链表分别含2^0~2^10个连续的空闲页框。 假设要找256个连续空闲页框，先定位到256对应的链表，如果没有再定位到512对应的链表，有的话就分割，并把剩余的256加入256对应的链表，以此类推。 3.4、slab分配器 对若干来自于buddy系统的页框块进行有效管理，以满足不同大小“对象”分配的请求。 kmalloc_index函数返回kmalloc_caches数组的索引。 kmalloc根据对象大小，到相应的缓冲区中进行分配。 当所分配对象大于8KB时，kmalloc维护的13个缓冲区已经无法使用了。 通过调用buddy系统获取页框。| kmalloc_caches数组索引 | 对象大小范围（字节） || ———————- | ——————– || 1 | (64, 96] || 2 | (128, 192] || 3 | (0, 8] || 4 | (8, 16] || 5 | (16, 32] || 6 | (32, 64] || 7 | (96, 128] || 8 | (192, 256] || 9 | (256, 512] || 10 | (512, 1024] || 11 | (1024, 2048] || 12 | (2048, 4096] || 13 | (4096, 8192] | 3.5、kmalloc和vmalloc kmalloc 根据flags找到slab中对应的kmem_cache（如__GFP_DMA，__GFP_NORMAL等），并从中分配内存。 分配的内存地址在物理地址和虚拟地址是上都连续。 vmalloc 分配的内存地址虚拟地址上连续，在物理地址上不要求连续。 需要建立专门的页表项把物理上不连续的页转换为虚拟地址空间上的页。映射时会出现TLB抖动，因为多次查映射表可能在TLB（Translation lookaside buffer，是一种硬件缓冲区）中不断切换。 3.6、用户态内存管理：mmap和brk 简单来说就是先从per-thread vma缓存中找再从红黑树中找满足大小要求的vm_area_struct。虚拟地址空间映射好后，物理内存的的分配与映射是通过page fault完成的。对于文件映射会先预读数据到内核中。如果指定了populate选项会直接先建立到物理内存的分配与映射。匿名映射是先创建一个创建一个临时的shm file（包括它的dentry，inode和file结构体）再与合适的vma映射。 mmap的那些范围通过vm_area_struct结构体管理。这个结构体以起始范围为key，通过红黑树连接起来，每个相邻的vm_area_struct之间同时还使用双向链表连接。 用户态与mmap有关的流程： 调用mmap，映射一个文件的一部分或者一段内存空间 如果mmap的时候要求populate，则需要先建立相关的映射（对于文件而言，需要预读数据到内核中，并建立映射关系；对于内存而言，需要映射相关的内存空间） 在用户态的运行过程中，可能会在访问某个地址时出现page fault。这时，page fault经过层层检查，发现是mmap的一段区域引发的，就会去建立映射关系（如上文）。 在建立好映射关系后，重新执行引起page fault的指令 调用msync或者取消映射时，对于文件而言，需要将数据刷到磁盘上 调用munmap取消映射 mmap内部的实现： 通过sys_mmap进入内核（函数实现在/arch/x86/kernel/sys_x86_64.c中） 调用到了sys_mmap_pgoff（函数实现在/mm/mmap.c中） 如果是非匿名映射，获取fd对应的file。如果file是大页文件系统的文件，将length对齐到2M 否则，如果设置了MAP_HUGETLB标志，在大页文件系统中创建一个file 调用vm_mmap_pgoff 安全检查 调用do_mmap_pgoff，这个函数转发数据到do_mmap。do_mmap的流程见下文。 如果用户指定了要populate，则调用mm_populate创建具体的映射关系 完成mmap，将file的引用计数减一 do_mmap 参数检查 获取未映射的内存区域 如果是文件映射，且file-&gt;f_op-&gt;get_unmapped_area不为NULL，则调用该函数搜索未映射的内存区域 如果是共享内存映射，则调用shmem_get_unmapped_area搜索未映射的内存区域 如果上述两者都为NULL，则调用current-&gt;mm-&gt;get_unmapped_area，该函数一般对应到arch_get_unmapped_area（位于/arch/x86/kernel/sys_x86_64.c中） 对其他参数进行检查 调用mmap_region进行映射。 mmap_region 将映射范围内原来的那些已经被映射的空间unmap掉 判断能否和前后范围内的vma合并，如果能合并，则函数返回 否则，新建一个vma并初始化 如果是文件映射，则调用file-&gt;f_op-&gt;mmap来进行具体的映射 否则，如果是匿名共享内存映射，则创建一个临时的shm file（包括它的dentry，inode和file结构体），并使用shmem_file_operations/shmem_inode_operations/shmem_aops等来初始化file/inode/address_space，对于vma，使用shmem_vm_ops来初始化 接下来，将vma加入到红黑树中 brk也会去把已经映射的区域unmap掉，然后再做mmap。brk其实是一个简陋的mmap，它不管文件，cow之类的问题，只匿名映射内存。在malloc的实现中，有了mmap，一般不会去调用brk，因为它有可能把原来的映射给释放掉。 3.7、内核地址空间共享机制 内核地址空间是共享的，每当fork一个进程时，内核会拷贝属于内核地址空间的那部分pgd表，使得所有的进程的pgd表中关于内核地址空间的部分都指向同样的pud表。 但是在运行过程中，内核可能又在vmalloc区域映射了一些新的页，而其他进程是不知道的，这些进程在陷内核访问这些页时，会触发page fault。在page fault的处理例程中，会去init_mm中查找对应区域的这些页表项，将这些页表项拷贝到触发page fault的进程的页表项中。（事实上，只有pgd表项为空，才会触发vmalloc的page fault） 对于内核module来说，如果在运行时动态加载了一个module，那么它的代码会被加载到一个专门的区域中，但这个区域并不在vmalloc区域内，那么内核中的其他进程怎么知道这一新映射的module代码的位置呢？事实上，这一区域能够被一个pgd表项cover住，那么，在fork的时候，所有进程的这一个pgd表项，已经对应到了同一个对应的pud页。内核在映射module的时候，是修改的pud/pmd等页表项，其他进程自然能够看到这一映射关系，而不会引发page fault 3.8、共享内存 这一套是在glibc里面实现的 shm_open创建一个file，获取对应的fd mmap映射fd munmap取消映射 shm_unlink减少引用计数 这一套机制是通过open在/dev/shm下面创建文件，用mmap来映射的。这套机制会经过fdtable，所以更为安全。 3.9、 ptmalloc ptmalloc通过mmap或brk（仅main_arena使用）每次批发64MB大小的内存（称为heap）来管理。 ptmalloc中有多个arena，即struct malloc_state。只有一个main_arena，其它的arena是动态分配的，但数量有上限，这些arena以链表的形式组织。分配内存找arena时可能会逐个对空闲的arena进行try_lock。 每个arena管理多个heap。每个heap通过prev指针连接起来，arena-&gt;top指向最近分配的heap中的，未分配给用户的，包含了heap尾部的那个chunk。通过arena-&gt;top，能够找到最近的那个heap。通过最近的那个heap的prev指针，能够依次找到以前所有的heap。 heap释放时会出现某一个heap未全部空闲则该heap前面的空闲的heap无法得到释放的问题。 用户请求的空间都用chunk来表示。 所有的空闲的chunk被组织在fastbin，unsorted bin，small bin，large bin中。 fastbin可看作small bin的缓存，缓存16B~64B（以8B递进，共10个）的chunk。 unsorted bin，small bin，large bin都是在bins数组中，只是不同index范围区分了他们。 chunk被分配出去时，其在空闲链表中的前后指针以及前后chunk size的字段会被复用给用户作为空闲区域。 每个线程有tcache，并且每个线程有一个thread_arena指向当前线程正在使用的arena。 unsorted bin可以看作small bin和large bin的缓冲，链表头是bins[1]。fastbin中的空闲chunk合并时会先放到unsorted bin中。分配时检查unsorted bin没有合适的chunk就会将unsorted bin中的chunk放到small bin或large bin中。 small bin中的chunk大小范围为32B~1088B（以16B递增，共62个bin链表，bin[2]~bin[63]）。 large bin中的chunk大小范围为1024B以上。 另外，每个线程有一个tcache，共64项，从最小的32字节开始，以16字节为单递增。 链表操作通过CAS，arena争用需要加锁。 3.10、jemalloc jemalloc 中大量使用了宏生成代码，比较晦涩。 通过避免 false cache line sharing，使用内存着色等，提高 cache line 效率 使用多个 arena 管理、更细粒度的锁、 tsd、tcache等，最小化锁竞争 使用 slab 分配不同大小的对象，精心选择 size classes，减少内存碎片 使用多层缓存，内存的释放和分配会经历很多阶段，提升速度 每个线程有一个thread specific data即 struct tsd_s tsd，其中有两个指针，iarena和arena分别指向用于元数据分配和用于普通数据分配的arena。所以，tsd需要找两个arena进行绑定（这两个arena可能是同一个）。 jemalloc会创建多个arena，每个线程由一个 arena 负责。arena有引用计数字段nthreads[2]，nthreads[0]计录普通数据分配arena指针绑定这个arena的次数，nthreads[1]记录元数据分配iarena指针绑定这个arena的次数。一个tsd绑定arena后，就不会改变arena。 有一个全局变量narenas_auto，它在初始化时被计算好，表示能够创建的arena的最大数量。 有多个arena，以全局数组的形式组织。每个线程有一个tcache，其中有指向某个arena的指针。 当需要绑定一个arena时，遍历所有已创建的arena，并保存所有arena中nthreads值最小的那个（根据是绑定元数据还是普通数据，判断使用nthreads[0]还是nthreads[1]）。 如果在遍历途中发现数组中有NULL（也就是说数组有slot，还可以创建新的arena），那么就创建一个新的arena，将arena放到那个slot中，并绑定在那个arena上 如果遍历途中发现所有的slot都被用上了，那么就选择nthreads值最小的那个，绑定那个arena jemalloc通过mmap以chunk（默认2M）为单位向操作系统申请内存。每个chunk的头部会有一个extent_node_t记录其元数据信息，如所属的arena和起始地址。这些chunk会以基数树的形式组织起来，保存 chunk 地址到 extent_node_t 的映射 jemalloc内部动态分配的内存通过base组织。base 使用 extent_node_t 组成的红黑树 base_avail_szad 管理 chunk。每次需要分配时，会从红黑树中查找内存大小相同或略大的、地址最低的 node， 然后从 node 负责的 chunk 中分配内存。 chunk 使用 Buddy allocation 划分为不同大小的 run。run 使用 Slab allocation 划分为固定大小的 region，大部分内存分配直接查找对应的 run，从中分配空闲的 region，释放就是标记 region 为空闲。 jemalloc 将对象按大小分为3类，不同大小类别的分配算法不同: small（8B-14K）: 从对应 bin 管理的 run 中返回一个 region large（16K-1792K）: 大小比 chunk 小，比 page 大，会单独返回一个 run huge（2M-64M）: 大小为 chunk 倍数，会分配 chunk mutex 尽量使用 spinlock，减少线程间的上下文切换 4. 进程管理 0号进程是idle进程，1号是init即 systemd进程，2号是kthreadd进程 当没有进程需要调度器调度时，就执行idle进程，其task_struct通过宏初始化，存放在内核data段 内核init_task即idle进程的栈大小：x64为16k，x86_32为8k task_struct内部存一个void *stack指向栈的基址 5. 地址空间 0000000000000000 - 00007fffffffffff (=47 bits) user space, different per mmhole caused by [47:63] sign extensionffff800000000000 - ffff87ffffffffff (=43 bits) guard hole, reserved for hypervisorffff880000000000 - ffffc7ffffffffff (=64 TB) direct mapping of all phys. memoryffffc80000000000 - ffffc8ffffffffff (=40 bits) holeffffc90000000000 - ffffe8ffffffffff (=45 bits) vmalloc/ioremap spaceffffe90000000000 - ffffe9ffffffffff (=40 bits) holeffffea0000000000 - ffffeaffffffffff (=40 bits) virtual memory map (1TB) //vmemmap，存放所有struct page* 用户地址空间 从低地址到高地址： text 代码段 —— 代码段，一般是只读的区域; static_data 段 = stack 栈区 —— 局部变量，函数的参数，返回值等，由编译器自动分配释放; heap 堆区 —— 动态内存分配，由程序员分配释放; 用户空间和内核空间 CPU其实并不知道什么用户空间和内核空间，它是通过PTE的U/S位与CPL来判断这个页是否可以被访问。所以，内核空间的那些页面对应的PTE与用户空间对应的PTE中，U/S位实际上是不同的，内核通过这一方式来划分用户空间和内核空间。 用户态显然不可以访问内核空间，但是内核态下也不一定就能访问用户空间。这与CPU的配置有关，规则很复杂，可以参考Intel手册卷三4.6节，这里提一个关键字SMAP，有兴趣可以自行搜索，在较新的内核版本中，这一机制已经被使用。 关于vdso和vvar：主要将部分安全的内核代码映射到用户空间，这使得程序可以不进入内核态直接调用系统调用。 线性地址空间划分如上图所示。内核空间的划分是确定的，写在内核代码中的，而用户态的空间在可执行文件被装载时才知道，由装载器和链接器来决定（可能需要参考elf相关的文档，才知道具体的装载位置）。不过，用户态空间整体的布局如上图所示，内核的current-&gt;mm结构体中记录着相关段的位置。 task_struct thread_info task_struct-&gt;active_mm 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 typedef unsigned long pgdval_t; typedef struct &#123; pgdval_t pgd; &#125; pgd_t; struct mm_struct &#123; // 管理mmap出来的内存，brk出来的也是在这brk就是一个简化版的 mmap, 只映射匿名页 struct vm_area_struct *mmap; struct rb_root mm_rb; // 通过红黑树组织 u32 vmacache_seqnum; /* per-thread vmacache */ pgd_t * pgd; // 页表指针，与 arch 相关, x64 下 pgd_t 为 unsigned long &#125;; struct task_struct &#123; struct thread_info thread_info; // 位于栈顶部，可用来定位 task_struct void *stack; // 指向栈 struct mm_struct *mm, *active_mm; // 内核线程没有 mm, 但有 active_mm // active_mm 用于 context_switch 时的加速 // 每个vma表示一个虚拟内存区域 // VMACACHE_SIZE 为 4，per-thread vma缓存 // 4.4 为 struct vm_area_struct *vmacache[VMACACHE_SIZE]; // 通过 #define VMACACHE_HASH(addr) ((addr &gt;&gt; PAGE_SHIFT) &amp; VMACACHE_MASK) // 决定vma的数组存储位置，PAGE_SHIFT 为 12，VMACACHE_MASK 为 VMACACHE_SIZE-1 即 3 struct vmacache vmacache; &#125;; struct vm_area_struct &#123; // [vm_start, vm_end) unsigned long vm_start; /* Our start address within vm_mm. */ unsigned long vm_end; // The first byte after our end address within vm_mm. unsigned long vm_flags; /* 设置读写等权限和是否为共享内存等等，见 mm.h */ /* linked list of VM areas per task, sorted by address */ struct vm_area_struct *vm_next, *vm_prev; // 2.6 只有 next struct rb_node vm_rb; struct mm_struct *vm_mm; /* The address space we belong to. */ /* Function pointers to deal with this struct. */ const struct vm_operations_struct *vm_ops; struct file * vm_file; /* File we map to (can be NULL). */ /* Information about our backing store: */ unsigned long vm_pgoff; /* Offset (within vm_file) in PAGE_SIZE units */ &#125;; struct vmacache &#123; u32 seqnum; // 4.4放在 task_struct 中, 当其与 mm_struct 中的 seqnum 不一致时缓存失效 struct vm_area_struct *vmas[VMACACHE_SIZE]; &#125;; 6. 文件系统7. 系统调用8. 信号9. IO管理10. 中断和异常1、中断、异常和陷入 中断：是为了设备与CPU之间的通信。 典型的有如服务请求，任务完成提醒等。比如我们熟知的时钟中断，硬盘读写服务请求中断。 断的发生与系统处在用户态还是在内核态无关，只决定于EFLAGS寄存器的一个标志位。我们熟悉的sti, cli两条指令就是用来设置这个标志位，然后决定是否允许中断。 中断是异步的，因为从逻辑上来说，中断的产生与当前正在执行的进程无关。 异常：异常是由当前正在执行的进程产生。异常包括很多方面，有出错（fault），有陷入（trap），也有可编程异常（programmable exception）。 出错（fault）和陷入（trap）最重要的一点区别是他们发生时所保存的EIP值的不同。出错（fault）保存的EIP指向触发异常的那条指令；而陷入（trap）保存的EIP指向触发异常的那条指令的下一条指令。 因此，当从异常返回时，出错（fault）会重新执行那条指令；而陷入（trap）就不会重新执行。 缺页异常（page fault），由于是fault，所以当缺页异常处理完成之后，还会去尝试重新执行那条触发异常的指令（那时多半情况是不再缺页）。 陷入的最主要的应用是在调试中，被调试的进程遇到你设置的断点，会停下来等待你的处理，等到你让其重新执行了，它当然不会再去执行已经执行过的断点指令。 关于异常，还有另外一种说法叫软件中断（software interrupt），其实是一个意思。 2、中断向量表 IDTR寄存器指向中断向量表。 11. 进程间通信12. 网络13.内核同步机制问题 内核RCU机制 seq_lock：写友好 rcu：读友好，更新时先拷贝，设置拷贝项的先修改再设置自身指向的前后指针，再设置前面的指向它，再设置自己指向后面的。删除时，与更新相同，只是最后释放的时候调用synchronize_rcu()或call_rcu()在一段间隔后回收，间隔(grace period)的确定是等待当前时间点所有未完成的read操作执行完 madvise 平常调用mmap实际调的是glibc的mmap，其对内核的系统调用mmap进行了封装，最终调用的是mmap2 -&gt; do_mmap sys_mmap源码应当搜索SYSCALL_DEFINE6(mmap，里面调用SYSCALL_DEFINE6(mmap_pgoff，再进入ksys_mmap_pgoff -&gt; vm_mmap_pgoff -&gt; do_mmap_pgoff -&gt; do_mmap mmap的最初起始位置有随机页偏移 内核配置一般是没有开启CONFIG_PREEMPT，只开启了CONFIG_PREEMPT_VOLUNTARY 内核的各种中断和异常 缺页异常的处理 内存碎片 CPU执行一条指令的过程：取指、译码、执行、访存、写回 CPU指令乱序： cpu为了提高流水线的运行效率，会做出比如：1)对无依赖的前后指令做适当的乱序和调度；2)对控制依赖的指令做分支预测；3)对读取内存等的耗时操作，做提前预读；等等。以上总总，都会导致指令乱序的可能。 但是对于x86的cpu来说，在单核视角上，其实它做出了Sequential consistency的一致性保障，指令在cpu核内部确实是乱序执行和调度的，但是它们对外表现却是顺序提交的，cpu只需要把内部真实的物理寄存器按照指令的执行顺序，顺序映射到ISA寄存器上，也就是cpu只要将结果顺序地提交到ISA寄存器，就可以保证Sequential consistency。 per-cpu变量和线程局部存储。]]></content>
      <categories>
        <category>cat</category>
      </categories>
      <tags>
        <tag>tags1</tag>
        <tag>tags2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[design patterns]]></title>
    <url>%2Fdesign-pattern%2Fdesign-patterns.html</url>
    <content type="text"><![CDATA[UML类图类的关系泛化（generalization） 继承非抽象类，箭头指向父类 实现（realize） 继承抽象类，箭头指向接口 聚合（aggregation） 整体和部分不是强依赖的，B不存在，A仍可存在 组合（composition） 强依赖的，B不存在，A也不存在 关联（association） 是一种拥有的关系,它使一个类知道另一个类的属性和方法。箭头指向被拥有者。 分为双向关联和单向关联。 老师与学生是双向关联，老师有多名学生，学生也可能有多名老师。但学生与某课程间的关系为单向关联，一名学生可能要上多门课程，课程是个抽象的东西他不拥有学生。 Indicator Meaning 0..1 Zero or one 1 One only 0..* Zero or more * Zero or more 1..* One or more 3 Three only 0..5 Zero to Five 5..15 Five to Fifteen 依赖（dependency） 描述一个对象在运行期间会用到另一个对象的关系 类的成员 画图顺序：类名，类成员变量，类的方法 public：+ private：- protected：# static：underlined 设计模式一、创建型模式（Creational） 对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离 创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的 1.1 简单工厂模式（Simple Factory） 根据参数的不同返回不同类的实例。当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。 适用于工厂类负责创建的对象比较少的情况，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。 优点： 将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性 缺点： 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。 应用： JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。 123public final static DateFormat getDateInstance();public final static DateFormat getDateInstance(int style);public final static DateFormat getDateInstance(int style, Locale locale); Java加密技术： 1234// 获取不同加密算法的密钥生成器:KeyGenerator keyGen=KeyGenerator.getInstance("DESede");// 创建密码器:Cipher cp=Cipher.getInstance("DESede"); 1.2 工厂方法模式（Factory Method） 在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。 如下图：某系统日志记录器要求支持多种日志记录方式，如文件记录、数据库记录等，且用户可以根据要求动态选择日志记录方式。 优点： 工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。 在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。 客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。 缺点： 在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。 1.3 抽象工厂模式（Abstract Factory） 在工厂方法模式中具体工厂负责生产具体的产品，每一个具体工厂对应一种具体产品，工厂方法也具有唯一性，一般情况下，一个具体工厂中只有一个工厂方法或者一组重载的工厂方法。但是有时候我们需要一个工厂可以提供多个产品对象，而不是单一的产品对象。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。 优点： 增加新的具体工厂和产品族很方便，无须修改已有系统 缺点： 增加新的工厂和产品族容易，增加新的产品等级结构麻烦 1.4 建造者模式（Builder） 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 用户使用不同的具体建造者即可得到不同的产品对象 。 与抽象工厂模式相比， 建造者模式返回一个组装好的完整产品 ，而 抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。 建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。 缺点：如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。 1.5 单例模式（Singleton） 由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。 1234567891011121314151617class Widget&#123;public: Widget(const Widget &amp;) = delete; Widget(Widget &amp;&amp;) = delete; Widget &amp; operator=(const Widget &amp;) = delete; Widget &amp; operator=(Widget &amp;&amp;) = delete;protected: Widget()&#123;&#125; ~Widget()&#123;&#125;public: static Widget &amp; GetInstance() &#123; static Widget w; return w; &#125;&#125;; 二、结构型模式（Structural） 描述如何将类或者对象结合在一起形成更大的结构，就像搭积木，可以通过简单积木的组合形成复杂的、功能更为强大的结构。 2.1 适配器模式（Adapter） 将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。 适配器模式有对象适配器和类适配器两种实现。 系统需要使用现有的类，而这些类的接口不符合系统的需要时可用此模式。 对象适配器： 类适配器： 优点： 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类。 对于类适配器：由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 对于对象适配器：一个对象适配器可以把多个不同的适配者适配到同一个目标，也就是说，同一个适配器可以把适配者类和它的子类都适配到目标接口。 缺点： 类适配器模式的缺点：对于Java、C#等不支持多重继承的语言，一次最多只能适配一个适配者类。 对象适配器模式的缺点：与类适配器模式相比，要想置换适配者类的方法就不容易。如果一定要置换掉适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。 2.2 桥接模式（Bridge） 将抽象部分与它的实现部分分离，使它们都可以独立地变化。 它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。行为型模式 桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。 2.3 装饰模式（Decorator） 将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为 动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。 装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。 使用装饰模式进行系统设计时将产生很多小对象，将增加系统的复杂度。 比继承更加易于出错，排错也很困难 2.4 外观模式（Facade） 外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码。 2.5 享元模式（Flyweight） 运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。 享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。 享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。 享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。 2.6 代理模式（Proxy） 给某一个对象提供一个代理，并由代理对象控制对原对象的引用。 远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。 远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 虚拟代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 智能引用代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。 图片代理：用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，先使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。如果用户在浏览大图时加载工作还没有完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览。 三、行为型模式（Behavioral） 对在不同的对象之间划分责任和算法的抽象化。 3.1 命令模式（Command） 将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 很多系统都提供了宏命令功能，如UNIX平台下的Shell编程，可以将多条命令封装在一个命令对象中，只需要一条简单的命令即可执行一个命令序列，这也是命令模式的应用实例之一。 3.2 中介者模式（Mediator） 用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 某论坛系统欲增加一个虚拟聊天室，允许论坛会员通过该聊天室进行信息交流，普通会员(CommonMember)可以给其他会员发送文本信息，钻石会员(DiamondMember)既可以给其他会员发送文本信息，还可以发送图片信息。 chatGroup即为中介，会员们都通过中介交互。 在具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 3.3 观察者模式（Observer） 定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。 3.4 状态模式（State） 允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。 状态模式的关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。 状态模式的使用必然会增加系统类和对象的个数。 3.5 策略模式（Strategy） 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。 一个系统需要动态地在几种算法中选择一种时可用此模式。 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。 参考 图解设计模式]]></content>
      <categories>
        <category>design pattern</category>
      </categories>
      <tags>
        <tag>design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpp notes]]></title>
    <url>%2Fcpp%2Fcpp-notes.html</url>
    <content type="text"><![CDATA[一、关键字1、volatile 起源：最早出现于 19 世纪 70 年代，被用于处理 memory-mapeed I/O (MMIO)带来的问题。 12345678unsigned int *p = GetMagicAddress(); // 可能不是内存地址而是I/O设备地址unsigned int a, b;a = *p; //（1）读I/O设备第一个intb = *p; //（2）读I/O设备第二个int*p = a; //（3）写入I/O设备第一个int*p = b; //（4）写入I/O设备第二个int// (1)和(2) 的乱序或直接将 b = a 会造成问题// (3)和(4) 可能被编译器优化消除掉，无意义的赋值 作用： 易变性：让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值 12a = f(c); b = a + 1; // 此时可能会直接拿 rax 寄存器中的值。gcc 4.1会，8.1不会，加volatile关键字则都不会 不可优化：即使是无用的常量也不会被优化消除掉，加-O2也不会 顺序性：gcc的优化仅保证一段程序的输出，在优化前后无变化。可能会改变前后两行变量的赋值顺序。 volatile变量与非volatile变量间的赋值顺序也可能被调换，JAVA不会。 volatile变量间的赋值顺序不会被调换 volatile仅保证编译器不会乱序，不保证CPU乱序 使用场景： 内嵌汇编操纵栈可能会导致出现编译无法识别的变量改变； 更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible； 中断服务程序中修改的供其它程序检测的变量需要加volatile； 多任务环境下各任务间共享的标志应该加volatile； 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义； 2、static 作用： 修饰全局变量 表示该符号仅在本编译单元内（一个.o文件）可见，也就是说，在链接时，这个名字不参与链接。 在.h中声明并定义static全局变量，每次某文件x去include这个.h文件都会在x中产生一份该变量，其修改不影响其他include了同一个.h文件的编译单元，因为都是独一无二的。 123456789101112131415161718192021222324//common.hstatic unsigned long val = 0xabcd; //如果此处不加static关键字，则编译会出现多重定义错误//a.c#include"common.h"void modify() &#123; val = 0xdeaddead;&#125;//b.c#include"common.h"#include&lt;stdio.h&gt;void show() &#123; printf("val is 0x%lx\n", val);&#125;//main.c#include "common.h"extern void modify();extern void show();int main() &#123; show(); modify(); show(); return 0;&#125;// 结果打印出来的都是 val is 0xabcd, a.c中的修改不影响b.c中的show()的val 解决办法如下： 1234//common.hextern unsigned long val;//common.cunsigned long val = 0xabcd; 修饰全局对象：全局对象的构造在main()之前，析构在main()之后。 这些操作的完成是通过编译时把这些初始化函数调用放到一个section中，运行时先运行这个section中函数指针指向的函数。 全局变量的初始化的顺序是不确定的，所以，如果一个全局变量的初始化依赖于另一个全局变量，这可能会导致很大的问题，因为被依赖的全局变量可能还没有被初始化。 全局变量位于.bss段或者.data段，取决于它的初始是否全为0.总而言之，全局变量的内存地址在加载elf文件时就已经确定了，不需要通过什么new/malloc之类的来分配。 static全局变量与普通全局变量的初始化是一样的，只是它们仅编译单元内可见。 修饰局部变量 类static成员变量：等价于修饰全局static变量，只是在访问这个变量时，需要用类名作为前缀修饰。 静态成员属于类作用域，但不属于类对象 不能在构造函数中进行初始化，因为其生命期与普通的静态变量一样，程序运行时进行分配内存和初始化，程序结束时则被释放。 静态变量成员需要在class{}（类定义体）内声明，类定义体外定义和初始化 静态常量成员可以在类定义体中直接初始化 函数static变量：在第一次访问时才做初始化的，当然，它的内存是早就已经分配好的。static局部变量的初始化在C++11后是保证线程安全的（c++11前不保证），故可用来实现单例模式。 修饰全局函数 static全局函数仅当前编译单元内可见 修饰类成员函数 其实就是普通的C函数，普通的成员函数是会传递this指针的，而static类成员函数不会，这也是为什么不能在static类成员函数中使用this指针的原因。 3、const 作用：通知编译器该变量是不可修改的。 const修饰的变量是占用内存的，这与#define定义常量是不同的。 123456int i = 0;int * const p1 = &amp;i; //p1不能变const int ci = 42;const int * p2 = &amp;ci; //p2指向的值不能变const int * const p3 = p2; //p3和p3指向的值都不能变const int &amp; r = ci; // 仅 const 引用可以引用 const 类型 const引用可以用不同类型的对象初始化，因为 const 引用实际是绑定到了一个临时变量上。 123double x = 1.1;const int&amp; y = x; // 合法，相当于 int tmp = x; const int&amp; y = tmp; 当然x改变，y读到的值也会变int&amp; z = x; // 错误！因为 int(x) 转换后的结果是一个右值，只能绑定到 const 左值引用上 在函数中，可以修饰参数和返回值。 在类中，可以修饰类的成员函数，则表明其不能修改类的成员变量。 对于类的成员函数，有时候必须指定其返回值为 const 类型，以使得其返回值不为“左值”。例如 operator+等运算符 4、extern 作用：声明（而非定义）函数或全局变量的作用范围，其声明的函数和变量可以在本模块活其他模块中使用 也就是说 B 模块(编译单元)要是引用模块(编译单元) A 中定义的全局变量或函数时，它只要包含 A 模块的头文件即可,在编译阶段，模块 B 虽然找不到该函数或变量，但它不会报错，它会在连接时从模块 A 生成的目标代码中找到此函数。 extern &quot;C&quot;：它告知编译器这个函数不需要使用name mangling机制，而是使用C的那一套机制。 5、explicit 禁止隐式转换：避免出现比如把一个int隐式转换为一个可通过int构造的对象。 6、inline与define define在预编译时做替换，避免了意义模糊的数字出现，不需要为这些常量分配存储空间 define缺乏类型检查机制，const可弥补这个缺点 并且其会在符号表中被看到，调试方便。 const 对象有明确的类型，可以保证类型安全性。 const 对象有作用域的限制。 inline函数在编译时展开，而宏是由预处理时进行展开 内联函数会检查参数类型，宏定义不检查函数参数 ，所以内联函数更安全。 宏不是函数，而inline函数是函数，用宏实现的函数功能有不可预知性。 宏在定义时要小心处理宏参数，（一般情况是把参数用括弧括起来）。 函数并不能完全替代宏，有些宏可以在当前作用域生成一些变量，函数做不到。 c++类定义体内的函数默认会inline 函数体过大时，编译器不会inline 二、概念1、new、delete、new[]和delete[] new/delete、new[]/delete[] 要配套使用 当用new[]为数组申请空间时，如果是基本类型或者传统trivial deconstructor类类型，可以使用delete进行释放，但是如果不是这种情况，必须使用delete[]进行析构。如果用delete进行释放，虽然能够调用一次析构函数，但事实上会出现内存访问出错，因为并不是指向真实的从malloc申请 delete如何知道要释放的数据的长度：ptmalloc在用户使用的一小段内存的前后需要加上辅助元数据信息，如下图： 对象数组：如果用delete释放只会释放第一个对象，应用delete[]，但仍有如下问题，最好办法就是用vector 1234567void f(A * pa)&#123; delete[] pa;&#125;B * pa = new B[10];f(pa);// 因为在f函数看来，数组中存放的是对象A，它会以sizeof(A)作为偏移来定位每个对象A，而实际上，数组存放的对象B，这样一来，对象就定位错了，这样一来，析构自然就出错了。 2、虚函数 虚析构：为了能够正确的调用对象的析构函数，一般要求具有层次结构的顶级类定义其析构函数为虚函数。因为在delete一个抽象类指针时候，必须要通过虚函数找到真正的析构函数。 纯虚析构：抽象类中用到，必须提供其定义。因为析构和构造函数都有固定的调用链，析构是从子类到父类逐个调用。 123456class Base&#123;public: virtual ~Base()= 0&#125;;Base::~Base() &#123; &#125; 构造函数不能是虚函数：因为调用构造函数时会设置好虚表，如果是虚构造函数那么虚表还没有设置好，相悖。 构造函数中不要调虚函数，因为构造顺序是从父类到子类，不会调到子类的虚函数实现。 override 1234// 父类virtual Base* clone();// 子类virtual Derived* clone() override; // 可以通过 三、对象模型1、空对象 单独一个空对象，大小是1，要确保两个不一样的对象拥有不同的地址 空对象作为父类，会有空基类优化，空基类的大小为0，或者说空基类与子类位于同一内存位置上。这个优化不仅仅针对第一个空基类。 12345678910111213141516171819class A&#123;&#125;;class B&#123;&#125;;class D&#123;&#125;;class C:public A, public B,public D&#123;public:&#125;;int main()&#123; cout &lt;&lt; sizeof(C) &lt;&lt; endl;&#125;// 仍然为 1 2、POD对象 总体表现的和C语言的struct一样。能够直接memcpy进行拷贝。 没有虚表指针 没有虚基类指针 使用编译器生成的ctor/dtor/copy ctor/move ctor/copy assign/move assign 它自己的non-static成员变量和父类也要满足这一点 很多时候C++对POD都有优化，比如在new一个class array时，如果class有自定义的dtor，除了分配足够大小的空间外，还需要额外分配一个空间用来记录array的大小（这样，在析构的时候，才能知道array的整体大小，以便于从后往前析构）。但是，对于POD，则不需要。 3、继承和虚表 怎么找虚函数的指针? 怎么获得虚函数真正需要的this指针? 见《c++资料整理.docx》 单继承： 1234567891011121314151617181920212223242526272829303132333435class A &#123;public: virtual ~A() &#123;&#125; virtual void f() &#123;&#125;private: int x;&#125;;class B : public A &#123;public: virtual ~B() &#123;&#125; virtual void f() override &#123;&#125;private: int y;&#125;;class C :public B &#123;public: virtual ~C() &#123;&#125; virtual void f() override &#123;&#125; virtual void g() &#123;&#125;private: int z;&#125;;/** +------------+C 的内存布局 | 0 |+---------+ |typeinfo_ptr|| vtblptr | ---&gt; | f || x | | dtor1 || y | | dtor2 || z | | g |+---------+ +------------+dtor1是不调用operator delte的，第二个调用operator deleteg的位置是放在dtor2后面的，因为每个virtual function的布局需要与父类保持一致。**/ non-virtual菱形继承 12345678910111213141516171819202122232425262728293031323334353637383940class A&#123;public: A():x(0xaaaaaaaa)&#123;&#125;int x;&#125;;class B:public A&#123;public: B():y(0xbbbbbbbb)&#123;&#125;int y;&#125;;class C:public A&#123;public: C():z(0xcccccccc)&#123;&#125;int z;&#125;;class D:public B, public C&#123;public: D():w(0xdddddddd)&#123;&#125; int w;&#125;;/** 每个对象再加两个虚函数f,gD 的内存布局 +---------+ | vtblptr | ---&gt; 虚表：对应 D，与 B 复用同一个。D::f, D::g, D::~D, D::~D| x | D 额外增加的函数也添加在这里| y | | vtblptr | ---&gt; 虚表：对应 C，通过 non-virtual thunk 跳回| x | | z | | w | +---------+ **/ virtual菱形继承 123456789101112131415class A&#123;... int x&#125;;class B:virtual public A&#123;... int y&#125;;class C:virtual public A&#123;... int z&#125;;class D:public B, public C&#123;... int w&#125;;/**D 的布局+---------+ | vtblptr | ---&gt; 虚表：对应B和D，但不包含仅写在A里的函数，这些函数通过先进行指针转换为虚基类再调用| y | | vtblptr | ---&gt; 虚表：对应 C， 通过 virtual thunk 跳回| z | | w | ---&gt; D::w| x | ---&gt; 对应虚基类 A::x 填在最后+---------+ **/ 指针转换 转虚基类指针：运行时确定，读Derive的vtblptr，拿到虚表中的to-vbase-offset，将Derive加上对应的offset 转非虚基类指针：能够在编译期确定偏移，直接this减去偏移就行了。 4、成员函数指针 对于非virtual函数，它就是一个普通的函数指针，指向一个地址。 对于virtual函数，它是该函数到虚表的偏移加一。如果这个值为0，则代表函数指针确实指向了NULL。 区分virtual和非virtual很简单，只需要看它的最后一位是否为1. 四、STL1、allocator 老版本因为有内存池，所以内存申请速度要比新版本快一些。但是在老版本里面，有两个十分严重的问题： 二级配置器中的 free list 虽然参考了伙伴系统中的数据结构，但是没有实现伙伴系统中的合并功能。也就是说两个 8 字节的块儿无法合并成 16 字节的块儿，即使 free list 里面的内存够用，也要再去一级配置器里面 malloc 一个 16 字节的块儿。它本身的目的是：用不合并小块的策略来提升速度，但是大大降低了内存使用效率。 即使程序员显式调用容器的析构函数，比如 map 的 clear()， malloc 也不把这些内存归还给 OS，而是缓存到自己的内存池。也就是说，它的内存池只会调用 malloc 申请内存，但从来不用 free 释放内存，所以只要程序不结束，STL 为容器分配的内存空间就没办法释放。 对于 g++-3.4.* 以后的版本，allocator 只是对 operator new 和 operator delete 进行了简单的封装。 因为现在高性能的分配器越来越多，比如 tcmalloc / jemalloc，所以已经完全没有必要再在 glibc 上提供一个专门用来分配内存空间的内存池了，何况那个内存池自身就有一些很严重的问题。 2、iterator 在STL中，原生指针也是一种迭代器，除了原生指针以外，迭代器被分为五类。 Input Iterator： 此迭代器不允许修改所指的对象，即是只读的。支持==、!=、++、*、-&gt;等操作。 Output Iterator：允许算法在这种迭代器所形成的区间上进行只写操作。支持++、*等操作。 Forward Iterator： 允许算法在这种迭代器所形成的区间上进行读写操作，但只能单向移动，每次只能移动一步。支持Input Iterator和Output Iterator的所有操作。 Bidirectional Iterator： 允许算法在这种迭代器所形成的区间上进行读写操作，可双向移动，每次只能移动一步。支持Forward Iterator的所有操作，并另外支持--操作。 Random Access Iterator： 包含指针的所有操作，可进行随机访问，随意移动指定的步数。支持前面四种Iterator的所有操作，并另外支持 it + n、it - n、it += n、 it -= n、it1 - it2 和 it[n] 等操作。 it++ 返回的是对象的拷贝，++it返回的是对象的引用，一般尽量使用 ++it 替换 it++ 。 3、traits 就是把一个模板类的特性抽出来，封装到另一个新构造的模板类里，用来做中间层。当函数，类或者一些封装的通用算法中的某些部分会因为数据类型不同而导致处理或逻辑不同时（而我们又不希望因为数据类型的差异而修改算法本身的封装时），traits会是一种很好的解决方案。 traits的作用就是把不同容器的iterator和内置的指针类型类型统一起来，使它们通过trait后，提供相同的类型接口。 123456789101112131415161718template &lt;typename T&gt;struct TraitsHelper &#123; static const bool isPointer = false;&#125;;template &lt;typename T&gt;struct TraitsHelper&lt;T*&gt; &#123; static const bool isPointer = true;&#125;;//iterator_traitestemplate&lt;class Iterator&gt;stuct iterator_traits&#123; typedef typename Iterator::iterator_category iterator_category; typedef typename Iterator::value_type value_type; typedef typename Iterator::difference_type difference_type; typedef typename Iterator::pointer pointer; typedef typename Iterator::reference reference;&#125;; 迭代器对应的 traits 类为 iterator_traits。 4、vector iterator : RandomAccessIterator vector容器是占用一段连续线性空间，所以vector容器的迭代器就等价于原生态的指针； 每当配置内存空间时，可能会发生数据移动，回收旧的内存空间，如果不断地重复这些操作会降低操作效率，所有vector容器在分配内存时，并不是用户数据占多少就分配多少，它会分配一些内存空间留着备用，即是用户可用空间。 内部数据结构：三个迭代器 start finish，start到此处为size() end_of_storage，start到此处为capacity() 容量扩大时增长为为__old_size + max(__old_size, __n)，即旧空间的两倍或旧空间加上要新增的容量大小。 5、string 元素是连续存储的 内部结构： 原子类型的引用计数 char* 指针，指向连续存储空间的开头位置 size 值 capacity 值 引用计数是用来完成写时拷贝的：string 之间拷贝时不是深拷贝，只拷贝了指针， 也就是共享同一个字符串内容，并且会有一个引用计数原子地加1。只有在内容被修改的时候，才真正分配了新的内存并 copy，并对原string的引用计数减一。 这就存在一个问题，比如A和B共享同一段内存，在多线程环境下同时对A和B进行写操作，可能会有如下序列：A写操作，A拷贝内存，B写操作，B拷贝内存，A对引用计数减一，B对引用计数减一，加上初始的一次构造总共三次内存申请，如果使用全拷贝的string，只会发生两次内存申请。 一些不经意操作可能导致意外的内存拷贝。 12345string s1("test for copy");string s2(s1);cout &lt;&lt; s2 &lt;&lt; endl; // sharedcout &lt;&lt; s2[1] &lt;&lt; endl; // 此处会重新申请并拷贝内存, 因为s2是非const的，调用的是非const的[]// 类似的操作的还有at(), begin(), end()等, 非const的string调用这些方法都会导致额外的内存申请和拷贝, 所以好的编程习惯应该是“在const的场景下使用const”。 6、list iterator：BidirectionalIterator 实现是循环双向链表。 单独实现了sort()，使用类似归并排序的思想：栈上建立64个元素的数组，每个存一个2^i长的链表的链表头，逐个遍历原始list的所有元素，先在第0个链表，之后合并放到第1个链表，再从头开始，类似2048游戏的思路。 std::forward_list是单向链表，比双向链表存储开销小。 7、deque1234567iterator insert( iterator pos, const T&amp; value ); //在pos前插入value, 返回被插入value的迭代器。reference front(); // const_reference front() const;reference back(); // const_reference back() const;void push_back( const T&amp; value );void pop_back();void push_front( const T&amp; value );void pop_front(); iterator : RandomAccessIterator 分段连续线性空间，随时可以增加一段新的空间。deque允许于常数时间内对头尾端进行插入或删除元素。 deque 的每次分配 node（缓冲区）都会分配完整的 512 个字节，使用完之后会继续分配新的缓冲区。 deque 有 size 和 max_size 方法获取已使用的空间和已分配的空间。 为了管理这些分段空间deque容器引入了一种中控器map，map是一块连续的空间，其中每个元素是指向缓冲区的指针，缓冲区才是deque存储数据的主体。 deque容器具有维护map和迭代器的功能，deque定义的两个迭代器分别是start和finish，分别指向第一个缓冲区的第一个元素和最后一个缓冲区的最后一个元素的下一个位置； 当对deque的元素进行排序时，为了提高效率，首先把deque数据复制到vector，利用vector的排序算法(利用STL的sort算法)，排序之后再次复制回deque。 一个deque相当大，占据80个字节。 12345678910template&lt;typename T&gt;class deque&#123; ...private: typedef T** map_pointer; deque_iterator&lt;T&gt; start;//32B seque_iterator&lt;T&gt; finish;//32B map_pointer map;//指向中央控制器头部, 8B size_type map_size; //8B&#125;; 迭代器： 123456789struct _Deque_iterator &#123; ... //以下是迭代器设计的关键，访问容器的节点 _Tp* _M_cur;//指向缓冲区当前的元素 _Tp* _M_first;//指向缓冲区的头(起始地址) _Tp* _M_last;//指向缓冲区的尾(结束地址) _Map_pointer _M_node;//指向中控器的相应节点 ...&#125;; 8、queue 无迭代器。 基于deque，只能在队列头部进行移除元素，只能在队列尾部新增元素，可以访问队列尾部和头部的元素，但是不能遍历容器。 1234void push( const value_type&amp; value );void pop();reference front(); // const_reference front() const;reference back(); // const_reference back() const; 9、stack 无迭代器。 默认基于deque，只能在栈顶对数据进行操作 123reference top(); // const_reference top() const;void push( const value_type&amp; value );void pop(); 10、priority_queue 无迭代器。 只能在队列尾部加入元素，在头部取出元素。 常数时间的（默认）最大元素查找，对数代价的插入与释出。 底层实现是一个 heap。 重载比较函数 内部元素为struct，直接重载其的operator&lt; std::priority_queue&lt;int, std::vector&lt;int&gt;, std::greater&lt;int&gt; &gt; 仿函数作为cmp函数，即struct内部重载operator() 11、heap heap 并不是一种容器，而是一种算法，任何能够提供随机访问迭代器的容器都能支持 heap 的操作。heap 不需要遍历内容，没有迭代器。heap 一般是基于 vector 容器的操作。 位置为i的完全二叉树，左孩子位置为2 * i + 1，右孩子位置为2 * i + 2 最大堆：是指根节点的关键字值是堆中的最大关键字值，且每个节点若有儿子节点，其关键字值都不小于其儿子节点的关键字值。 12345678910#include &lt;algorithm&gt;//检查范围[first, last)中的元素是否为（默认）最大堆。template&lt; class RandomIt, class Compare &gt;bool is_heap( RandomIt first, RandomIt last, Compare comp ); // 在范围 [first, last) 中构造（默认）最大堆。void make_heap(...);void push_heap(...);void pop_heap(...);void sort_heap(...); 12、pair 是一个struct，提供了两个成员变量first和second，提供了构造函数和拷贝构造函数，同时提供了两个最基本的操作operator==和operator&lt;重载，其他的操作符重载都是基于前面两种的变形。 13、set1234567891011121314template&lt; class Key, class Compare = std::less&lt;Key&gt;, class Allocator = std::allocator&lt;Key&gt;&gt; class set;// 返回由指向被插入元素（或阻止插入的元素）的迭代器和若插入发生则设为 true 的 bool 值。std::pair&lt;iterator,bool&gt; insert( const value_type&amp; value );size_type count( const Key&amp; key ) const;iterator find( const Key&amp; key ); // const_iterator find( const Key&amp; key ) const;// 返回容器中所有拥有给定关键的元素范围。范围以二个迭代器定义，一个指向首个不小于 key 的元素，另一个指向首个大于 key 的元素。std::pair&lt;iterator,iterator&gt; equal_range( const Key&amp; key );iterator lower_bound( const Key&amp; key ); // 返回指向首个不小于 key 的元素的迭代器。iterator upper_bound( const Key&amp; key ); // 返回指向首个大于 key 的元素的迭代器。 iterator：BidirectionalIterator 基于红黑树，容器键key和值value是相同的。且在容器里面的元素是根据元素的键值自动排序的。 14、map iterator：BidirectionalIterator 基于红黑树 15、multiset和multimap 允许键值重复，底层插入用的是rb-tree的insert_equal而非insert_unique。 16、unordered_(multi)map和unordered_(multi)set iterator：ForwardIterator 底层采用hash table，默认采用开链法来解决冲突问题。 17、hash table 在每个表格元素中维护一个链表, 然后在链表上执行元素的插入、搜寻、删除等操作，该表格中的每个元素被称为桶(bucket)。 解决碰撞（colllision）： 线性探测（linear probing）： 插入：当遇到相同的值的时候，顺序往下一一寻找，直到找到第一个空位。 删除：惰性(laze)删除，找到需要删除的值，标记删除，等重新整理（rehashing），不惰性删除而直接置空则空位后还可能有元素。 二次探测（quadratic probing）： 插入：当遇到相同值的时候，向后移动 i^2，即：1，4，9，… 删除：标记删除 开链法（separate chaining）： 为每一个表格元素维护一个list，插入和删除操作都在hash后对应的list上进行 STL即采用此做法 扩展方式：虽然开链法不要求表格大小为质数，但仍按照质数扩展。实际从11，23，53开始的28个质数，每个至少是前一个的两倍。 totalElementNum &gt; MaxLoadFactor * currentBkts时扩展 桶扩展的时候会停止服务，为了减少扩展次数，我们可以调用reserve 源码中实现的是FNV（Fowler-Noll-Vo）哈希 18、迭代器失效 在使用erase方法来删除元素时，需要注意一些问题。 vector的迭代器在内存重新分配时将失效，删除元素时，指向被删除元素以后的任何元素的迭代器都将失效。 list的erase获取下一个有效位置，set，map等以不连续的节点形式存储的容器类似 12List.erase( itList++); // 或itList = List.erase( itList); vector和deque只能用itVec = Vec.erase(itVec);，第二种不行，对于序列式容器(如vector,`deque`)，删除当前的iterator会使后面所有元素的iterator都失效。这是因为vetor,deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置。还好erase方法可以返回下一个有效的iterator。 五、c++111、六大函数123456789class Widget&#123; Widget()&#123;&#125; // 默认构造函数 Widget(const Widget &amp;)&#123;&#125; // 复制构造 Widget(Widget &amp;&amp; )&#123;&#125; // 移动构造 Widget &amp; operator=(const Widget &amp;)&#123;&#125; // 复制赋值 Widget &amp; operator=(Widget &amp;&amp;)&#123;&#125; // 移动赋值 ~Widget()&#123;&#125;&#125;; 2、四种cast2.1 dynamic_cast 用于将一个父类对象的指针转换为子类对象的指针或引用。这是一种运行期的类型检查。 要求被转换的对象必须有虚函数，否则编译会报错。 对于不合法的转换，dynamic_cast会失败，对于指针的转换，如果失败，会返回0，而对于引用，由于引用不可能指向一个空的obj，因此，引用转换失败时，会抛出bad_cast异常。 2.2 static_cast 相当于C语言的cast 不做运行时的检查，不如dynamic_cast安全。 用于静态转换，可用于任何转换，但它不能用于两个不相关的类型转换，比如不能转化struct类型到int，不能转化指针到double等。另外，它不能在转换中消除const、volatile和__unaligned属性。 2.3 const_cast 编译时的指令，去掉const属性或者volatile属性。 const_cast一个确定是const的数据，是未定义行为。 12const char * ps = "helloworld";const_cast&lt;char *&gt;(ps)[0] = 'a'; // 运行时会 segment fault const int a真实实现是通过一个符号映射表来实现，如果不对a进行取地址，那么a在栈上不占任何空间，一旦对a取地址，那么会在栈上分配一个空间存储a对应的100，修改b时相当于修改了栈上的空间，真正访问a时，会直接参考符号映射表得到100。这也能反映出编译器对常量的保护是做得比较到位的。 2.4 reinterpret_cast 编译时的指令，重新解释这块内存的类型。 3、RAII Resource Acquisition Is Initialization，内存获取即初始化。很多东西都可以用RAII来管理，不仅仅是内存，还有锁，比如lock_guard等等。 3.1 shared_ptr m_ptr m_refcount use_count：为0时，会dispose掉对象，仅析构掉对象，并不回收空间。 weak_count：另外受weak_ptr影响。为0时，destroy对象，不仅析构对象，也回收内存。 3.2 weak_ptr 只影响weak_count的引用计数。 它在lock的时候返回一个shared_ptr，如果weak_ptr指向的对象的use_count已经为空，那么它的返回的shared_ptr指向nullptr。 解决循环引用问题。 3.3 enable_shared_from_this 继承enable_shared_from_this&lt;T&gt;后，调用shared_from_this()可返回指向T的shared_ptr。 3.4 unique_ptr unique_ptr的类型信息与shared_ptr不一样，shared_ptr的deleter不算作类型的一部分，而unique_ptr的deleter算作类型的一部分。也就是说，关于同一指针的不同deleter的unique_ptr不是同一种类型。 unique_ptr的deleter是跟着对象本身的，而没有放在什么控制块里面。unique_ptr中对象的所有权通过右值引用的方式转移。std::move() 如果deleter是一个对象（仿函数、lambda）且没有任何成员变量的话，deleter实际上不占任何内存空间。但是如果deleter是一个函数指针，那么它必定占用内存空间。 4、RTTI run time type info，每个类型（类，整型，enum，指针（函数指针，成员函数指针，对象指针，成员变量指针））都有对应的type info，都能通过typeid关键字来获取它们的typeinfo。 拥有虚表指针的类，可以在它们的虚表中找到它们的type info，而且，dynamic_cast的实现正是依赖于这些type info，因此，只有拥有虚表指针的类才能使用dynamic_cast。 5、右值引用 凡是真正的存在内存当中，而不是寄存器当中的值就是左值，其余的都是右值。其实更通俗一点的说法就是：凡是取地址（&amp;）操作可以成功的都是左值，其余都是右值。 f(int &amp;&amp; x) ，x本身是左值，但它是一个右值引用。 函数的返回值不一定是右值，如operator[]函数 std::move无条件地把它的参数转换成一个右值，而std::forward只在特定条件满足的情况下执行这个转换。 std::move和std::forward在运行期都没有做任何事情。 std::forward只有在它的参数绑定到一个右值上的时候，它才转换它的参数到一个右值。会保留参数的左右值类型。 12345678910111213141516171819202122232425262728class Test &#123; int * arr&#123;nullptr&#125;;public: Test():arr(new int[5000]&#123;1,2,3,4&#125;) &#123; cout &lt;&lt; "default constructor" &lt;&lt; endl; &#125; Test(const Test &amp; t) &#123; cout &lt;&lt; "copy constructor" &lt;&lt; endl; if (arr == nullptr) arr = new int[5000]; memcpy(arr, t.arr, 5000*sizeof(int)); &#125; Test(Test &amp;&amp; t): arr(t.arr) &#123; cout &lt;&lt; "move constructor" &lt;&lt; endl; t.arr = nullptr; &#125; ~Test()&#123; cout &lt;&lt; "destructor" &lt;&lt; endl; delete [] arr; &#125;&#125;;Test createTest() &#123; return Test();&#125;int main() &#123; Test t(createTest());&#125; 打印结果为（编译时加上-fno-elide-constructors，关闭返回值优化（RVO），否则只有第一行和最后一行）： 123456default constructormove constructordestructormove constructordestructordestructor 与std::move()相区别的是，move()会无条件的将一个参数转换成右值，而forward()则会保留参数的左右值类型。 123456789101112131415161718192021222324template &lt;typename T&gt;void func(T t) &#123; cout &lt;&lt; "in func " &lt;&lt; endl;&#125;template &lt;typename T&gt;void relay1(T&amp;&amp; t) &#123; cout &lt;&lt; "in relay" &lt;&lt; endl; func(t); &#125;template &lt;typename T&gt;void relay2(T&amp;&amp; t) &#123; cout &lt;&lt; "in relay " &lt;&lt; endl; func(std::forward&lt;T&gt;(t)); // &#125;int main() &#123; relay1(Test()); // func 的参数 t 调用 copy constructor, 为左值 relay2(Test()); // func 的参数 t 调用 move constructor, 为右值 Test t; relay1(t); // func 的参数 t 调用 copy constructor, 为左值 relay2(t); // func 的参数 t 调用 copy constructor, 为左值&#125; 通用引用（universal reference）：必须满足T&amp;&amp;的形式，类型T必须是通过推断得到的。 1234567891011121314151617template &lt;typename T&gt;class TestClass &#123;public: //这个T&amp;&amp;不是一个通用引用，因为当这个类初始化的时候这个T就已经被确定了，不需要推断 void func(T&amp;&amp; t) &#123;&#125; &#125;// 普通函数模版参数，是通用引用template &lt;typename T&gt;void f(T&amp;&amp; param);// auto 声明，是通用引用auto &amp;&amp; var = ...;void f(const string &amp; s) // 可以过编译，但去掉const就不行，"hello world"是个右值&#123; cout &lt;&lt; s &lt;&lt; endl;&#125;f("hello world"); 6、引用与指针 初始化：引用在创建时必须初始化，引用到一个有效对象；而指针在定义时不必初始化，可以在定义后的任何地方重新赋值。 指针可以是NULL，引用不行。 引用貌似一个对象的小名，一旦初始化指向一个对象，就不能将其他对象重新赋值给该引用，这样引用和原对象的值都会被更改。 引用的创建和销毁不会调用类的拷贝构造函数和析构函数。 指针是对象，占据内存；引用不是，不一定占据内存。（考虑int a; int&amp; r = a;编译器做的优化，以及引用作为形参时必须占据存储） 7、对象切割（Object slicing） 当把一个派生类对象赋给一个基类对象时，会发生对象切割。 多态的实现是通过指针和引用；而对象的转换只会造成对象切割，不能实现多态。 12345678910111213141516171819202122232425262728293031323334353637class Base &#123; protected: int i; public: Base(int a) &#123; i = a; &#125; virtual void display() &#123; cout &lt;&lt; "I am Base class object, i = " &lt;&lt; i &lt;&lt; endl; &#125; &#125;; class Derived : public Base &#123; int j; public: Derived(int a, int b) : Base(a) &#123; j = b; &#125; virtual void display() &#123; cout &lt;&lt; "I am Derived class object, i = " &lt;&lt; i &lt;&lt; ", j = " &lt;&lt; j &lt;&lt; endl; &#125; &#125;; // Global method, Base class object is passed by value void somefunc (Base obj) &#123; obj.display(); &#125; int main() &#123; Base b(33); Derived d(45, 54); somefunc(b); somefunc(d); // Object Slicing, the member j of d is sliced off return 0; &#125; // 输出：// I am Base class object, i = 33// I am Base class object, i = 45 8、lambda表达式 [ captures 捕获列表 ] ( params ) -&gt; ret { body } lambda有两种默认捕获模式，按值捕获或者按引用捕获。默认情况下[]不捕获任何东西，[&amp;]表示按引用捕获每个变量，[=]表示按值捕获。 12345template&lt;typename T1, typename T2&gt;auto f(T1 a, T2 b)-&gt;decltype(a+b)&#123; return a+b;&#125; 闭包（closure）：是由一个lambda创建的运行期对象。闭包持有捕获数据的副本或引用 闭包类（closure class）：闭包类是用于实例化一个闭包对象的，编译器为每个lambda参数一个独一无二的闭包类，lambda表达式中的代码会成为闭包类成员函数的可执行指令。 lambda与仿函数是等价的，完全可以用仿函数来仿照lambda，只是很不方便。 不能捕获全局变量，不能捕获static或线程局部存储变量。 捕获的变量可能在lambda被调用时生命周期已经结束。 不能直接捕获类的成员变量，只有捕获this指针，才能在lambda里面直接用成员变量。 9、function bind的返回值不是function，而是一个仿函数。这个仿函数可以作为function的构造函数的参数，来构造一个function。其实，不用function来接bind的结果，而用auto来接也是完全可以的。 就算你拿到了某个lambda表达式的类型，也无法用这个类型来创建一个lambda对象，即下面的表达式是不能过编译的，原因在于lambda类型的构造函数被声明为delete的了。 123auto func = []&#123;cout &lt;&lt; "helloworld" &lt;&lt; endl;&#125;;decltype(func) funcopy;funcopy(); 其它 C语言也有auto关键字，默认表示int类型，auto是一个隐含的默认存储类型，相对于static，register，extern等而言。 C语言不允许函数重载，因为编译时不会像C++一样对函数名做name mangling c++中函数的名字有函数的namespace、函数名、参数共同组成。 nm命令可以查看符号表 c++filt命令可以得到原始的名字 C语言可以通过函数指针来实现重载，调用的时候选择指向不同的函数]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>programe language</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMU Peloton Optimizer]]></title>
    <url>%2Fcode-reading%2Fpeloton-optimizer.html</url>
    <content type="text"><![CDATA[优化器BuildParseTree libpg_query：裁剪出的postgresql的语法解析和词法解析。 BuildParseTree：对parser生成的语法树进行解析，得到SelectStatement，其中记录了语句的各个组件。 1234567891011class SelectStatement : public SQLStatement &#123; std::unique_ptr&lt;TableRef&gt; from_table; bool select_distinct; std::vector&lt;std::unique_ptr&lt;expression::AbstractExpression&gt;&gt; select_list; std::unique_ptr&lt;expression::AbstractExpression&gt; where_clause; std::unique_ptr&lt;GroupByDescription&gt; group_by; std::unique_ptr&lt;SelectStatement&gt; union_select; std::unique_ptr&lt;OrderDescription&gt; order; std::unique_ptr&lt;LimitDescription&gt; limit;&#125;; BindNameToNode 主要是用于检查SelectStatement中涉及的列的合法性，并将列的属性（如属于哪一张表）填入各表达式。 BuildPelotonPlanTreeOptimizer::InsertQueryTree QueryToOperatorTransformer::ConvertToOpExpression：将SelectStatement转换为一棵树。树中节点如下 LogicalQueryDerivedGet：用于from中的子查询。 LogicalInnerJoin：默认对from中的表进行Join，解析到from时会生成join树，不带条件。 如果from中显示的指定了哪一类Join，会生成对应类型的Join，如LogicalLeftJoin。 LogicalGet：递归解析from中的元素时会解析到底层的TableRef，生成此节点。 LogicalFilter：根据where中的谓词生成。having子句也会生成LogicalFilter。 LogicalMarkJoin：用于IN和EXISTS子链接。 LogicalSingleJoin：用于expr op sublink，op为比较运算符时生成。 LogicalAggregateAndGroupBy LogicalDistinct：单独的节点，在LogicalAggregateAndGroupBy之后生成。 LogicalLimit：在LogicalDistinct后生成。 OptimizerMetadata::RecordTransformedExpression： 将上一步生成的树中的节点逐个转换为group_expression，每个group_expression。 封装层次：Group &lt;- GroupExpression &lt;- Operator &lt;- BaseOperatorNode &lt;- &lt;LogicalFilter...&gt; Optimizer::GetQueryInfo 提取output_exprs和sort_exprs作为后面优化的参考。 Optimizer::OptimizeLoop 通过TaskStack来遍历树，具体规则应用顺序： BottomUpRewrite -&gt; TopDownRewrite -&gt; DeriveStats -&gt; OptimizeGroup BottomUpRewrite和 TopDownRewrite 都是应用规则直接替换原来的节点。 DeriveStats 通过栈实现自底向上的方式统计。主要统计以下信息： 123456size_t num_rows;double cardinality;double frac_null;std::vector&lt;double&gt; most_common_vals,std::vector&lt;double&gt; most_common_freqs;std::vector&lt;double&gt; histogram_bounds; OptimizeGroup 先对LogicalExpression通过OptimizeExpression应用TransformationRule和ImplementationRule，得到多个group，并且Expression转换为了PhysicalExpression。 OptimizeExpression 对当前GroupExpression添加ApplyRule，规则为所有TransformationRule和ImplementationRule。 对当前的child Group调用ExploreGroup。 ExploreGroup 对Group内的所有LogicalExpressions调用ExploreExpression。 ExploreExpression 对当前GroupExpression添加ApplyRule，规则为所有TransformationRule和ImplementationRule。并且此ApplyRule设置了explore_only标志。 对当前的child Group调用ExploreGroup。 ApplyRule 每次对以当前GroupExpression为根节点的子树应用规则。 通过GroupExprBindingIterator遍历子节点的Group，但是每次Next()返回都是当前GroupExpression，只是子节点在每次调用HasNext()时变化。 通过GroupBindingIterator遍历其中的LogicalExpression。 在应用TransformationRule后会重新调用DeriveStats。 应用规则后得到的新的子树的根节点GroupExpression会被放到原来的GroupExpression所在的Group中，其新生成的子节点都会位于不同的Group。 OptimizeInputs ChildPropertyDeriver：有的算子可能会要求前置节点的数据有序，如（PhysicalSortGroupBy），将此种属性下推到子节点。 选择每个Group中开销最小的GroupExpression作为最佳节点，之后转换为PhysicalPlan节点。 优化规则TransformationRule InnerJoinCommutativity —–&gt; + InnerJoinAssociativity —–&gt; ### ImplementationRule+ LogicalGroupByToHashGroupBy+ LogicalAggregateToPhysical+ GetToSeqScan+ LogicalQueryDerivedGetToPhysical+ InnerJoinToInnerNLJoin+ InnerJoinToInnerHashJoin+ ImplementDistinct+ ImplementLimit### RewriteRule+ Bottom Up：UNNEST_SUBQUERY + PullFilterThroughMarkJoin —–&gt; PullFilterThroughAggregation —–&gt; MarkJoinToInnerJoin：即算子转换。 Top Down：PREDICATE_PUSH_DOWN PushFilterThroughJoin —–&gt; PushFilterThroughAggregation —–&gt; CombineConsecutiveFilter —–&gt; EmbedFilterIntoGet：即选择下推。 其它 visitor模式在遍历子树时较方便。]]></content>
      <categories>
        <category>code reading</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>code reading</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scheduling algorithms]]></title>
    <url>%2Fscheduling-algorithm%2Fscheduling-algorithms.html</url>
    <content type="text"><![CDATA[Workflow scheduling in cloud: a surveyModeling and definition static workflow scheduling Task selection Select the first task from the scheduling list; Resource selection Allocate the task to selected resource. List scheduling heuristic static: priorities are constructed before any task allocationdynamic: the priorities of unscheduled tasks are recomputed after each task scheduling step List Scheduling AlgorithmCritical-Path algorithm Parallel sequencing and assembly line problems (1961)自底向上，每次选择已经准备好的节点分配到准备好的机器上, 离 $exit$ 节点路径长的优先调度忽略消息传输时间 Modified Critical-Path (MCP) algorithm Hypertool A Programming Aid for Message-Passing Systems (1990)MCP Revisited (2000)每次选择 $ALAP$ 时间最小的节点进行调度, 当有多台机器可用时, 选择调度后整体通信开销最小的 Dynamic-Level Scheduling (DLS) algorithm A Compile-Time Scheduling Heuristic for Interconnection-Constrained Heterogeneous Processor Architectures (1993)Highest Levels First with Estimated Times (HLEFT) algorithm : Just like Critical-Path algorithmHighest Dynamic Levels First with Estimated Times (HDLEFT) algorithm先选就绪P, 再选合适的task, 或者两个同时考虑一起选的方式较优HDLEFT’s inherent flaw: 限制了一个可执行的任务只能从当前就绪的处理器中选择一个执行. 因为有 global clock 的存在Dynamic Level Scheduling (DLS) algorithmStatic Level: 当前节点到 exit 节点的所有执行时间之和, 不包括通信时间Dynamic Level: $DL(N_i, P_j, \sum) = SL(N_i) - \max [DA(N_i, P_j, \sum), TF(P_j, \sum)]$]]></content>
      <categories>
        <category>scheduling algorithm</category>
      </categories>
      <tags>
        <tag>scheduling algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TPCH test scripts]]></title>
    <url>%2Fdatabase%2Ftpch.html</url>
    <content type="text"><![CDATA[Usage123456789cd tpch/dbgencp makefile.suite Makefile# modify the Makefile# CC = gcc# DATABASE = ORACLE# MACHINE = LINUXmake./dbgen -h./dbgen -vf -s 1 for postgresql1find -name &quot;*.tbl&quot; | xargs sed -i &quot;s/|$//&quot;]]></content>
      <categories>
        <category>database</category>
      </categories>
      <tags>
        <tag>tpch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《统计学习方法》]]></title>
    <url>%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%2Fstatistical-learning-method.html</url>
    <content type="text"><![CDATA[前言 只摘录关键知识点，不做详细笔记，仅为方便日后复习有个方向 学习: 如果一个系统能够通过执行某个过程改进它的性能，这就是学习。 — Herbert A. Simon 1.统计学习 统计学习的特点，对象，目的，方法，研究 本章主要将监督学习 监督学习 从给定有限的训练数据出发, 假定数据是独立同分布的, 而且假设模型属于某个假设空间, 应用某一评价准则, 从假设空间中选取一个最优的模型, 使它对已给训练数据及未知测试数据再给定评价标准意义下有最准确的预测. 基本概念：input space, output space, feature space 其它名词：instance, feature vector, 联合概率分布 假设空间: $ \mathcal{F} = \{ f\;| \mathit{Y} = f(X) \} $ 最终变成求 $\min\limits_{f\in\mathcal{F}}R_{emp}(f)$ 或 $min_{f\in\mathcal{F}}R_{srm}(f)$ 的问题 统计学习三要素 方法 = 模型 + 策略 + 算法 策略 损失函数: 0-1, quadratic, absolute, logarithmic 风险函数(期望损失): $ R_{exp}(f) = E_{p}[L(Y, f(X))] = \int_{x\times y}L(y, f(x))P(x,y)dxdy $ 经验风险(经验损失)(empirical loss): $\displaystyle R_{emp}(f) = \frac{1}{N}\sum_{i=1}^{N}L(y_i, f(x_i)) $ 根据大数定理, 可用$R_{emp}(f)$估计$R_{exp}(f)$, 但由于现实中样本有限, 甚至很少，所以需要矫正$R_{emp}(f)$ 经验风险最小化(ERM)和结构风险最小化(SRM) ERM: 用最优化方法求解$\min\limits_{f\in\mathcal{F}}R_{emp}(f)$ 样本容量很小时容易过拟合(over-fitting), 但样本容量大时，学习效果很好 当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计(MLE)(证明). SRM: 等价于正则化(regularizer), 即求 $\min\limits_{f\in\mathcal{F}}R_{srm}(f)$ 结构风险: $\displaystyle R_{srm}(f) = R_{emp}(f) + \lambda J(f)$ 其中 $\lambda J(f)$ 位正则化项或罚项(penalty term) $J(f)$是模型空间复杂度, 为定义在$\mathcal{F}$上的泛函. $f$越复杂, $J(f)$越大. $\lambda \ge 0$是系数, 用以权衡经验风险和模型复杂度 $R_{srm}(f)$小要求$R_{emp}(f)$和$J(f)$同时小, $R_{srm}(f)$小的模型往往对训练数据以及未知的测试数据都有较好的预测 当模型是条件概率分布, 损失函数是对数损失函数, 模型复杂度由模型的先验概率分布表示时，结构风险最小化就等价于最大后验概率估计(MAP)(证明) 模型评估与选择 训练误差(tranning error): 模型关于训练数据集的平均损失 测试误差(test error): 模型关于测试数据集的平均损失, 反映了模型的预测能力(泛化能力 generalization ability) 过拟合: 所选模型参数过多, 对训练数据预测的很好, 对测试数据预测的很差 模型选择时要选择复杂度适当的模型, 防止过拟合. 正则化与交叉验证 此为常用的两种模型选择方法 正则化 $\min\limits_{f\in\mathcal{F}}R_{srm}(f)$ 正则化项: 一般是模型复杂度的单调递增函数，模型越复杂，正则化值越大 如参数向量$w$的$L_1$范数$\parallel w_1 \parallel$或$L_2$范数$\frac{1}{2}\parallel w_1 \parallel^2$ 模型越复杂, 先验概率越大 交叉验证 样本充足时, 可随机切成训练集(用于训练模型), 验证集(用于模型选择, 选择预测误差最小的模型)和测试集(模型评估) 交叉验证: 重复使用数据, 反复切, 反复训练, 测试及模型选择 简单交叉验证: 随机切成训练集和测试集, 选测试误差最小的模型 $S$折交叉验证(S-fold cross validation): 切成$S$份, 每次选$S-1$份训练, $1$份测试, 重复$S$次 留一交叉验证: $S=N$, 数据集为$N$, 数据集较少时用 泛化能力 即模型$\hat{f}$的预测能力, 用$R_{exp}(\hat{f})$来表示 泛化误差上界: $R(f) \le \hat{R}(f) + \varepsilon(d, N, \delta)$ $R(f)$为泛化误差$\le$右边为泛化误差上界$\hat{R}(f)$为训练误差$\varepsilon(d, N, \delta) = \sqrt{\frac{1}{2N}(\log d + \log \frac{1}{\delta})}$ 训练误差小的模型, 泛化误差也会小 生成模型与判别模型 监督学习的方法可以分为: 生成方法(generative approach)和判别方法(discriminative approach) 生成方法: 先学习$P(X,Y)$再求出$P(Y|X) = \frac{P(X,Y)}{P(X)}$ 如:朴素贝叶斯法和隐马尔可夫模型 判别方法: 直接学习$f(X)$或$P(Y|X)$ 如:$k$近邻法, 感知机, 决策树, 逻辑斯蒂回归模型, 最大熵模型, 支持向量机, 提升方法和条件随机场等存在隐变量时, 判别方法不能用 分类问题 $P(Y|X)$作为分类器 分类准确率(accuracy): 对于给定的测试数据集, 分类正确的样本数与总样本数之比 精确率(precision):$P = \frac{TP}{TP+FP}$ True, False, Positive, Negative 召回率(recall): $R = \frac{TP}{TP+FN}$ $P$和$R$的调和均值$F_1$: $\frac{1}{F_1} = \frac{1}{P} + \frac{1}{R}$, 即$F_1 = \frac{2TP}{2TP+FP+FN}$ 许多统计学习方法可以用于分类 如: $k$近邻法, 感知机, 朴素贝叶斯法, 决策树, 决策列表, 逻辑斯蒂回归模型, 支持向量机, 提升方法, 贝叶斯网络, 神经网络, Winnow等 标注(tagging)问题 可以认为书分类问题的推广，也是更复杂的结构预测(structure prediction)问题的简单形式 输入一个观测序列$x_{N+1} = (x_{N+1}^{(1)}, x_{N+1}^{(2)}, x_{N+1}^{(3)}, … ,x_{N+1}^{(n)})^T$, 找到使条件概率$$P((y_{N+1}^{(1)}, y_{N+1}^{(2)}, y_{N+1}^{(3)}, … ,y_{N+1}^{(n)})|(x_{N+1}^{(1)}, x_{N+1}^{(2)}, x_{N+1}^{(3)}, … ,x_{N+1}^{(n)})$$最大的标记序列$y_{N+1} = (y_{N+1}^{(1)}, y_{N+1}^{(2)}, y_{N+1}^{(3)}, … ,y_{N+1}^{(n)})^T$ 常用的标注方法:隐马尔科夫模型`和条件随机场 回归问题 等价于函数拟合: 选择一条函数曲线使其很好地拟合已知数据且很好地预测未知数据 分类 按输入变量的个数: 一元回归和多元回归输入与输出变量的关系模型: 线性回归和非线性回归损失函数是平方损失函数时: 可用最小二乘法(least squares)求解 2.感知机(preceptron) 属于判别模型, 输入为实例的特征向量, 输出为实例的类别是一种线性分类模型 感知机模型 $f(x) = sign(\omega\cdot x + b), 其中sign(x) = \begin{cases} +1, &amp;{x \ge 0} \\ -1, &amp;{x \lt 0} \end{cases} $ 线性分类器: $f(x) = \lbrace f|f(x) = \omega\cdot x + b \rbrace$ 感知机学习策略 数据集的线性可分性: 存在某个超平面$ S: \omega\cdot x + b = 0 $能够将数据集的正实例点和负实例点完全正确的划分到超平面的两侧 即对所有实例$i$有: $y_i = \begin{cases} +1, &amp;{\omega\cdot x + b \ge 0} \\ -1, &amp;{\omega\cdot x + b\lt 0} \end{cases} $ 感知机就是要找出这样一个超平面，即确定$\omega$和$b$, 定义(经验)损失函数并将损失函数极小化 损失函数: $\displaystyle L(\omega, b) = -\sum_{x_i \in M} y_i(\omega\cdot x_i + b)$其中$M$为所有误分类点的集合 感知机学习算法 即求解$\displaystyle \min_{\omega, b} L(\omega, b)$的最优化问题 任意选取一个超平面$\omega_0, b_0$, 然后用梯度下降法不断地极小化目标函数选取$y_i(\omega\cdot x_i + b) \le 0$$$ \omega \gets \omega + \eta y_i x_i$$ $$ b \gets b + \eta y_i $$$\eta(0\le\eta\lt 0)$是步长, 又称为学习率 算法的收敛性证明 即证明: 设数据集是线性可分的, 经过有限次迭代可以得到一个将训练数据集完全正确划分的分离超平面及感知机模型最终得到误分类次数$k \le (\frac{R}{\gamma})^2$, 其中$\displaystyle R = \max_{1\le i \le N}\parallel \hat{x}_i \parallel$当训练集线性不可分时, 算法不收敛, 迭代结果会发生震荡 对偶形式 感知机模型$\displaystyle f(x) = sign(\sum_{j=1}^N \alpha_j y_j x_j\cdot x + b)$其中$\alpha_i = n_i\eta$, 且迭代过程为: $\begin{cases} \alpha_i &amp; \gets \alpha_i + \eta \\ b &amp; \gets b + \eta y_i \end{cases}$ 3.$k$-NN ($k$-nearest neighbor) 一种基本的分类与回归的方法 算法 实例 $x$ 所属的类$y$, 有:$$\displaystyle y = \arg\max_{c_j}\sum_{x_i \in N_k(x)} I(y_i = c_j), \;\;\;\; i = 1,2,\cdots ,N; \;\; j=1,2,\cdots ,K$$ $k=1$时为最近邻法 $k$近邻模型 模型三要素: 距离度量, $k$值的选择和分类决策规则的确定 距离度量 一般用欧式距离, 也可以是其它距离, 如$L_p$距离(Minkowski距离): $\displaystyle L_p(x_i, x_j) = \left(\sum_{l = 1}^n |x_i^{(l)} - x_j^{(l)}|^p\right)^{\frac{1}{p}}$ 欧式距离: $p=2$曼哈顿距离: $p=1$各个坐标距离的最大值: $p=\infty$ $k$的选择 较小: 近似误差小, 估计误差大 较大: 近似误差大, 估计误差小 应用中通常选取较小的$k$值, 采用交叉验证法选取最优的$k$值 分类决策规则 经验风险最小化: 即$\displaystyle \sum_{x_i \in N_k(x)} I(y_i = c_j)$最大化 $k$近邻法的实现: $kd$树 $kd$树是一种对$k$维空间进行存储以便对其进行快速检索的树形数据结构. $kd$树的每个节点对应于一个$k$维超矩形区域. 此处的$k$与$k$近邻法的$k$不同. $kd$树搜索的平均时间复杂度为$O(\log N)$, 更适用于训练实例数远大于空间维数时的$k$近邻搜索. 当空间维数接近训练实例数时, 它的效率会迅速下降, 几乎接近线性扫描. 4.朴素贝叶斯法 朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法 朴素贝叶斯法与贝叶斯估计时不同的概念 朴素贝叶斯法的学习与分类 朴素贝叶斯分类器可以表示为:$$\displaystyle y = \arg\max_{c_k} P(Y=c_k) \prod_j P(X^{(j)}=x^{(j)}|Y=c_k) $$ 即后验概率最大化 后验概率最大化的含义: 根据期望风险最小化准则可以得到后验概率最大化准则 朴素贝叶斯法的参数估计 极大似然法 在朴素贝叶斯法中, 学习意味着估计$P(Y=c_k)$和$P(X^{(j)}=x^{(j)}|Y=c_k)$ 先验概率$P(Y=c_k)$的极大似然估计为: $\displaystyle P(Y=c_k) = \frac{\displaystyle\sum_{i=1}^N I(y_i = c_k)}{N}, \;\; k=1,2,\cdots,K$ 设第$j$个特征$x^{(j)}$可能取值的集合为$\lbrace a_j1, a_j2, \cdots, a_{jS_j} \rbrace$, 条件概率$P(x^{(j)}=a_{jl} |y=c_k)$的极大似然估计是:$$P(X^{(j)}=a_{jl} |Y=c_k) = \frac{\displaystyle \sum_{i=1}^N I(x_i^{(j)}=a_{jl} , y_i=c_k)}{\displaystyle\sum_{i=1}^N I(y_i = c_k)}$$$$j=1,2,\cdots,n; \;\; l=1,2,\cdots,S_j; \;\; k=1,2,\cdots,K$$ 朴素贝叶斯算法 贝叶斯估计: 极大似然估计可能出现所要估计的概率为$0$的情况, 这会影响到后验概率的计算结果, 使分类产生偏差, 解决这一问题的方法是采用贝叶斯估计$$P_\lambda (X^{(j)}=a_{jl} |Y=c_k) = \frac{\displaystyle \sum_{i=1}^N I(x_i^{(j)}=a_{jl} , y_i=c_k) + \lambda}{\displaystyle\sum_{i=1}^N I(y_i = c_k) + S_j \lambda } \;\;\;\;$$$$P_\lambda (Y=c_k) = \frac{\displaystyle\sum_{i=1}^N I(y_i = c_k) + \lambda}{N + K\lambda}$$其中$\lambda \ge 0$, $\lambda = 0$是极大似然估计, $\lambda = 1$是拉普拉斯平滑(Laplace smoothing) 5.决策树 决策树是一种基本的分类与回归方法 本质上是从训练数据集归纳出一组分类规则 决策树学习通常包括三个步骤: 特征选择, 决策树的生成和决策树的修剪 内部节点表示一个特征或属性, 叶节点表示一个类 决策树模型与学习 损失函数通常是正则化的极大似然函数 需要自下而上进行剪枝, 去掉过于细分的叶节点, 使其回退到父节点, 甚至更高的节点, 避免过拟合, 使其有更好的泛化能力 决策树的生成只考虑局部最优, 决策树的生成则考虑全局最优 特征选择 通常的特征选择的准则是信息增益或信息增益比 熵(entropy): $\displaystyle H(p) = \sum_{i=1}^n p_i \log p_i$ 条件熵(conditional entropy): $\displaystyle H(Y|X) = \sum_{i=1}^n p_i H(Y|X=x_i)$ 当熵和条件熵中的概率由数据估计(特别是极大似然估计得到)时, 所对应的熵与条件熵分别称为经验熵与经验条件熵 信息增益表示得知特征$X$的信息而使得类$Y$的信息的不确定性减少的程度 特征$A$对训练数据集$D$的信息增益$g(D,A) = H(D) - H(D|A)$, 也成为互信息(mutual information) 信息增益比:$$g_R (D,A) = \frac{g(D,A)}{H_A(D)}$$其中，$H_A (D)$表示训练数据集$D$关于特征$A$的值的熵$$\displaystyle H_A (D) = -\sum_{i=1}^n \frac{|D_i|}{D} \log_2 \frac{|D_i|}{D}$$ 决策树的生成ID3算法 输入: 训练数据集D, 特征集A, 阈值\varepsilon每次选择$ g(D,A) $最大的特征点递归构建, 直到所有特征的$g(D,A)$均很小($\lt\varepsilon$)或没有特征可以选择为止 C4.5算法 用信息增益比来选择特征 决策树的剪枝 损失函数: $C_\alpha (T) = C(T) + \alpha |T|$, 其中$$\displaystyle C(T) = \sum_{t=1}^{|T|}N_t H_t (T) \;\;\;\;\; H_t (T) = -\sum_k \frac{N_{tk}}{N_t} \log \frac{N_{tk}}{N_t}$$$N_{tk}$表示树$T$的某一叶节点$t$的第$k$类样本点的数量 若一组叶节点回缩前后的树分别为$T_B$和$T_A$, 当$C_\alpha (T_A) \le C_\alpha (T_B)$时进行剪枝, 将父节点变为新的叶节点 利用损失函数最小原则进行剪枝就是用正则化的极大似然估计进行模型选择 CART算法 分类与回归树(Classification and Regression Trees)递归构建二叉决策树再剪枝具体见《统计学习方法》 CART生成 回归树的生成: 用平方误差最小化准则, 最小二乘回归树生成算法 分类树的生成: 用基尼系数选择最优特征, 同时决定该特征的最优二值切分点 CART剪枝 首先从生成算法产生的决策树$T_0$底端开始不断剪枝, 直到$T_0$的根节点, 形成一个子树序列$\lbrace T_0, T_1, \cdots, T_n \rbrace$;然后通过交叉验证法再独立的验证数据集上对子树序列进行测试, 从中选择最优子树 6.逻辑斯蒂回归与最大熵模型 逻辑斯蒂回归(logistic regression)是统计学习中的经典分类方法最大熵是概率学习的一个准则, 将其推广到分类问题得到最大熵模型(maximum entropy model)两者都属于对数线性模型 逻辑斯蒂回归 设$X$是连续随机变量, $X$服从逻辑斯蒂分布是指$X$具有下列分布函数和密度函数:$$ F(x) = P(X \le x) = \frac{1}{1+e^{-(x-\mu)/\gamma}} $$$$ f(x) = F’(x) = \frac{e^{-(x-\mu)/\gamma}}{\gamma(1+e^{-(x-\mu)/\gamma})^2} $$ 该曲线是以点$(\mu, \frac{1}{2})$为中心堆成的$S$型曲线 7.支持向量机 支持向量机(support vector machines SVM)是一种二分类模型 线性可分支持向量机与硬间隔最大化 线性可分支持向量机 给定线性可分的训练数据集, 通过间隔最大化或等价地求解相应的凸二次规划问题学习得到的分离超平面为 $$ w^\ast \cdot x + b^\ast = 0 $$ 以及相应的分类决策函数 $$ f(x) = sign(w^\ast \cdot x + b^\ast) $$ 称为线性可分支持向量机 函数间隔: 对于给定的训练数据集$T$和超平面$(w,b)$, 定义超平面$(w,b)$关于样本点$(x_i, y_i)$的函数间隔为$$\hat{\gamma_i} = y_i(w\dot x_i + b)$$定义超平面$(w,b)$关于训练数据集$T$函数间隔为超平面$(w,b)$关于$T$中所有样本点$(x_i, y_i)$的函数间隔之最小值, 即$$\displaystyle \hat{\gamma} = \min_{i=1,2,\cdots,N} \hat{\gamma_i}$$ 几何间隔: $$\gamma_i = y_i\left(\frac{w}{\parallel w \parallel} \cdot x_i + \frac{b}{\parallel w \parallel} \right)$$ $$\displaystyle \gamma = \min_{i=1,2,\cdots,N} \gamma_i$$ 间隔最大化]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>统计学习方法</tag>
        <tag>machine learning</tag>
        <tag>book</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Self-Driving Database Management Systems (CIDR’17)]]></title>
    <url>%2Fpaper-reading%2FSelf-Driving-Database-Management-Systems.html</url>
    <content type="text"><![CDATA[介绍 以往数据库调优是 DBA 在问题发生后进行调整，self-driving （自治）数据库不仅优化当前工作负载，还可以预测以后的负载情况，从而事先做好准备，并且可以为现代高性能数据库提供更多复杂的新的优化方案。Peloton 通过深度学习实现了self-driving。 现存的自动调优技术例如：Self-Tuning 物理数据库技术，自动选择索引、自动对表分区存储、自动创建和更新物化视图。自动选择底层存储方式（H2O， 2014），自动设置数据库配置参数，拷贝并及时更新所需索引的DataBase Cracking 技术，云数据库动态资源配置等等。但以上都只用于解决单一的问题，没有从全局考虑，而且 DBA 不一定能了解那么多方面去修复或优化一个系统，而且无法预测未来的负载从而提前做出决策。 问题概述 了解应用的工作负载，HTAP（hybrid transaction analytical processing）可能执行事务和查询的时间几乎是同时的，所以不能用为 OLAP 和 OLTP 分别创建一个数据库的方法。HTAP 可自动的选择是使用 OLAP 还是 OLTP 的方式来优化。 需要预测资源使用率的趋势。如错开高峰时段进行更新，对即将可能出现的问题提前告警。 有了预测能力之后，DBMS 需要为预计的负载情况选择合适的优化方式。Self-driving 不支持需要数据库外部信息（如权限，数据清理和版本控制）的 DBA 任务，支持以下这些操作。对于每一个优化动作，DBMS 不仅需要估计其部署后的开销，还要估计部署它所需要的开销。 需要确定何时生成及采用相应的优化动作。即需要动态学习和改变，以适应负载的改变。 两个额外的限制：代码不能因为上层需求改变而需要重构；它不能依赖于仅支持某些编程环境的程序分析工具。 Self-Driving 架构 现存的数据库在修改表1 中的Actions时常常需要重启，并且速度也比较慢。自研一个新的DBMS架构能很好的嵌入self-driving组件，并且提供更细粒度的控制。使用多版本并发控制（MVCC）来使得 OLTP 事务不会阻塞 OLAP 查询。使用内存管理、lock-free数据结构和flexible layout使得HTAP工作负载可以快速执行(即 Peloton 的实现)。 Peloton架构如Figure 1，系统在不需要任何除环境（例如内存上限，目录路径等）外的其它信息就可以实现自动学习如何降低延迟（数据库最重要的性能指标），目前主要考虑延迟，其它的指标（分布式环境服务开销和能耗）可通过增加限制来优化。 Peloton中有一个Workload Monitor来监控事件流的资源使用情况和DBMS /OS遥测数据、优化动作的问题出现和结束时机。之后通过这些数据预测负载情况，找出系统瓶颈和其它问题（如索引丢失，节点过载）然后选择最佳执行动作，并且执行的同时进行检测和学习。 负载分类 第一个功能组件是通过无监督学习的方式将具有相似特性的应用查询进行聚合，即对负载进行聚类，可以减少模型数量，更容易预测应用行为。Peloton最初的实现是DBSCAN算法（原本用于聚合OLTP负载）。 一个很大的问题就是用什么查询特性来进行聚类，有两种：一是查询runtime metrics，虽然这对可以在不需要理解其意义的情况下进行聚类，但是其对数据库内容和底层物理设计的变化更敏感，对高并发的负载也会出现类似的问题；二是查询逻辑语义，基于逻辑执行计划（如表和谓词）来分类，其独立于数据库内容和底层物理设计，但是需要考虑其是否能生成好的模型，并且为了runtime metrics的精度所付出的训练代价是值得的。不过，有可能模型变化不大，收敛快，且由于硬件加速使得开销小。 还有一个问题就是如何确定类簇已经不再正确了。Peloton采用交叉验证（留一小部分数据集作为验证集）来确定何时类簇的错误率超过阈值，并且可以探索执行动作是如何影响查询的，从而决定何时重新训练模型。 负载预测 为每一种负载的查询的出现率做预测，除了异常的热点之外，这种预测使系统能够识别负载周期性和数据增长趋势，从而为负载波动做准备。在DBMS执行查询之后，它用其簇标识符标记每个查询，然后填充一个直方图，该直方图跟踪在一个时间段内到达每个群集的查询的数量。Peloton使用这些数据来训练预测模型，这些模型估计了应用程序在将来执行的每个簇的查询数量。DBMS还在事件流中为其他DBMS/OS指标构建了类似的模型。 ARM被用来做时序数据的线性关系分析，但是数据库可能被多个因素影响，并不符合线性假说。 RNN对预测时序数据的非线性模型很有效。LSTM是RNN的一个变种，可以学习时序数据的周期性规律。 RNN的准确性依赖于其训练数据集的大小，Peloton为每个Group维护多个RNN（不同的时间范围和间隔）来预测负载。尽管这种粗粒度的RNN不太准确，但是减少了DBMS必须在运行时维护的训练数据的大小和预测所需的开销。 Action Planning &amp; Execution 将自动化部件与DBMS进行紧耦合可以使得各部分之间提供反馈。还可以将增强学习应用于并发控制和查询优化 Action Generation：Peloton会搜索可能提升性能的Action，并且将action及其调用后对系统的影响记录在catalog中。这种搜索是由预测模型引导的，这样系统就会寻找能够提供最大收益的操作。它还可以删除冗余操作，以减少搜索的复杂性。可以根据资源需求及使用情况决定分配多少个CPU核来执行action。Action资源分配的knob为增量更改而非绝对值。某些action还有相应的reverse action，如 add/drop index。 Action Generation: Peloton会搜索可能提升性能的Action，并且将action及其调用后对系统的影响记录在catalog中。这种搜索是由预测模型引导的，这样系统就会寻找能够提供最大收益的操作。它还可以删除冗余操作，以减少搜索的复杂性。可以根据资源需求及使用情况决定分配多少个CPU核来执行action。Action资源分配的knob为增量更改而非绝对值。某些action还有相应的reverse action，如 add/drop index。 在RHCM之下，计划流程（planning process）被组织为树状，每一层包含某个时刻数据库可调用的action，系统根据这些action的成本效益（cost-benefit）来决定调用哪一个action，也有可能一个action都不调用。一种搜索方式是随机选择树上层次更深的action而非评估所有的action（参考alpha go的论文）。对当前数据库状态和预期负载效益更好的action更可能被考虑（加权），同时最近被reverse的action会被避免调用。 一个action的开销(cost)是对部署（deploy）这个action的时间和数据库因此性能下降情况的估计。对于没有调用过的action的分析，通过回馈机制分析某一类型的action来改善。一个action的效益(benefit)是在执行（intsall）这个action后在查询延迟上带来的改变，即查询样例的开销加权总和，权重为预测出来的相应查询的到达率。而且时域（time horizon）也会作为权重考虑，这使得直接模型（immediate model）会对最终的成本效益分析有更大的影响。 此外，action对Peloton的内存使用率的影响也会在cost-benefit分析的时候考虑，任何导致DBMS内存超限的action都会被忽略。 RHCM的horizon的值比较微妙，太短的话，在即将到来的负载峰值时DBMS来不及进行准备；太长的话，突然出现的问题无法及时得到优化解决，因为模型太慢了。除此之外，由于计算每个time epoch的cost-benefit是昂贵的，所以可以创建另一个深度神经网络从而用一个值函数来近似它们。 Deployment：Peloton支持非阻塞地deploying actions。例如，对表进行迁移或重组并不影响其它查询的访问。一些操作，比如添加索引，需要特别考虑，以防在action执行过程中因为因为数据被修改而产生影响。 DBMS还处理来自集成机器学习组件的资源调度和争用问题。使用单独的联合处理器或GPU来处理繁重的计算任务将避免减慢DBMS的速度。否则，DBMS将不得不使用单独的机器，专门用于所有的预测和计划组件。这将使系统的设计复杂化，并由于协调而增加额外的开销。 Additional Considerations DBA对于self-driving的不信任，可以将决策写成人类可读的形式，比如为什么添加索引，它的负载跟之前哪一个很相似，为何添加索引可以带来优化。另外，还需要提示DBA是否需要进行OLTP或者OLAP的优化，以及数据库的重要性优先级。Peloton也会像其它action一样记录DBA的手动操作，并且记录其效益，同时也允许DBA决定此记录何时过时，以防止消除误操作带来长期的影响。]]></content>
      <categories>
        <category>paper reading</category>
      </categories>
      <tags>
        <tag>paper reading</tag>
        <tag>database</tag>
      </tags>
  </entry>
</search>
